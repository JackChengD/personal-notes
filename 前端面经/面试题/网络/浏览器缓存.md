# 浏览器缓存

浏览器缓存分为强缓存和协商缓存。当浏览器向服务器请求数据时会看有没有缓存，先看有没有强缓存，没有就看有没有协商缓存，没有的话再向服务器拿数据，然后再放到缓存里。

> 强缓存：在http1.0时会看请求头部的expires字段是否过期，http1.1后加入了cache-control
> 协商缓存：在http1.0时看请求头的If-Modified-Since跟Last-Modified，http.1.1后先根据If-None-Match跟Etag。

为什么既有Last-Modified还有Etag

>- HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题

1. 一些文件也许会周期性的更改，但是他的内容并不改变(只是时间发生修改)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改(比如说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
3. 某些服务器不能精确的得到文件的最后修改时间

>- 这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务端的唯一标识符。Last-Modified与Etag是可以一起使用的，服务器会优先验证ETag，不一致的情况下，才会继续比对Last-Modified，最后才确定是否返回304

Cache-Control有什么值
> public，资源允许被中间服务器缓存。浏览器请求服务时，如果缓存时间没到，中间服务器直接返回浏览器内容，而不必请求资源服务器。
> private，资源不允许被中间服务器缓存，浏览器请求服务器时，中间服务器都要把浏览器的请求透传给服务器。
> no-cache，不管本地副本是否过期，每次访问资源，浏览器都要向服务器询问，如果文件没有变化，服务器只告诉浏览器继续使用缓存（304）。
> no-store，浏览器和中间代理服务器都不能缓存资源。每次访问资源，浏览器都必须请求服务器，并且，服务器不去检查文件是否变化，而是直接返回完整的资源。
> must-revalidate，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。
> proxy-revalidate，要求代理服务器针对缓存资源向服务器确认。
> maxage：缓存服务器对资源缓存的最大时间。

参考：`https://www.cnblogs.com/chenqf/p/6386163.html`
