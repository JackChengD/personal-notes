# tcp三握四挥

> 三次握手--TCP连接需要三次握手

1. 第一次握手：建立连接时，客户端发送syn（同步序列编号）包（syn=j）给服务端，并进入SYN_SEND状态，等服务器确认
2. 第二次握手：服务器收到syn包，必须确认客户端的SYN（ack=j+1），同时自己也发送一个syn包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（k+1），此包发送完毕，客户端进入建立状态。服务端收到确认后进入建立状态，完成三次握手，此时双方可以开始通信

为什么是三次

主要是确认双方数据报文的起始序列号  
防止已经失效的连接请求报文又传到了服务器，进而产生错误。  
如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。  

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接  

参考: https://blog.csdn.net/qzcsu/article/details/72861891

> 四次挥手--断开一个TCP连接需要四次挥手

1. 第一次挥手：主动关闭方发送一个FIN（关闭连接），用于关闭主动方到被动方的数据传送，也就是主动关闭方告诉被动方：不会再给你发送数据了（当然，在FIN包之前发送出来的数据，如果没收到对应的ack确认报文，主动方依然会重发这些数据），但是，此时主动方还是接受数据
2. 第二次挥手：被动关闭方收到FIN后，发送一个ACK给对方，确认需要为收到序号+1（与SYN相同，一个FIN占用一个序号）
3. 第三次挥手：被动关闭方发送一个FIN，用于关闭被动关闭方到主动关闭方的数据传送，也就是告诉关闭方，我的数据也发送完了，不会再给你发送数据了
4. 第四次挥手：主动方收到FIN后，发送一个ACK给被动方，确认序号为收到序号+1。至此，完成四次挥手

