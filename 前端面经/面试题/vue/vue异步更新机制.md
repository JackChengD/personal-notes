# vue异步更新机制

调用dep.notice后，对里面的所有依赖进行排序，然后遍历执行它（watcher）的update方法，，update会判断如果是懒执行，就会将dirty置为true，如果是同步，就直接执行run方法，一般都是执行queueWatcher(this)，然后会拿到watcher的id看是否已经进入过队列了，如果是就直接跳过，没有则入队将其标记置为true，通过判断flushing是否处在刷新队列中，如果不是直接push到队尾，如果是则将其插入到队列指定位置，是根据id从小到大进行排序的。如果waiting为false，就会开始执行flushSchedulerQueue函数，如果是同步就直接执行，异步则通过nextTick执行，将函数传入，nextTick会有一个全局的callbacks数组会push一个函数（对回调函数进行包装然后用try、catch捕获异常），之后看pending是否为false，false则执行timerFunc()函数并将pending置为true，timerFunc函数会判断当前支持哪种异步方式(Promise、MutationsObserver、setImmediate、setTimeout)，会将flushCallbacks传进去，flushCallbacks会将pending置为false，赋值一个callbacks数组，然后清空数组，最后遍历复制后的数组执行里面的回调函数也就是我们前面的flushSchedulerQueue函数或者用户传进来的函数。

flushSchedulerQueue函数，会将flushing置为true表示正在刷新队列，对queue进行排序，遍历执行里面的watcher.run()方法，从而进入更新阶段，比如执行组件更新函数或者执行用户watch的回调函数。

参考： https://juejin.cn/post/6951568091893465102  
参考： https://www.bilibili.com/video/BV1ey4y1x7hx  
