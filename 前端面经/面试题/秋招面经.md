# 面试题--回答仅供参考
## B站
### 一面
1.基本数据类型 Symbol是什么
>- 基本的数据类型有number、string、boolean、null、undefined、Symbol
>- Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值。
>Symbol()函数返回的是Symbol类型的值，该类型具有静态方法和静态属性。
>- Symbol可参考：https://www.jianshu.com/p/425148370333

2.js的深浅拷贝
1. 浅拷贝
>- 引用类型浅拷贝--地址指向相同
>- 把一个数组直接等于另一个数组，这只是把存放的地址拷贝过去，两个指向指的是同一个地址，所以改变其中一个的值，被拷贝也跟着改变。
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr;
    brr[1] = 6
    console.log(arr);//[1,6,2,3,4,5]
    console.log(brr);//[1,6,2,3,4,5]
```
>- 基本数据类型浅拷贝
>- 值在内存中占据这固定大小的空间，并被保存在栈内存中。当一个变量向另一个变量复制基本类型的值，会创建这个值的副本，并且我们不能给基本类型的值添加属性
```javascript
    var a = 1;
    var b = a;
    b.name = '小明';
    console.log(a);//1
    console.log(b);//1
    console.log(b.name);//undefined
    b = 2;
    console.log(a);//1
    console.log(b);//2
```

2. 深拷贝---自身属性、方法改变互不影响
>- 将引用类型的属性、方法拷贝一份给另一个引用类型
>- 用例如下：
>- 使用数组(forEach)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    arr.forEach((item,index)=>{
        brr[index] = item;
    })
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(map)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.map(item=>item)
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(slice)截取--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.slice(0);
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(concat)合并--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.concat();
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用for-in遍历拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    for(const key in arr){
        brr[key] = arr[key]
    }
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- ES6语法...实现深拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [...arr];
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```

3.js怎么判断两个对象相等
>- 采用JSON.stringfy();
```javascript
    var arr = {a:1,b:2};
    var brr = {a:1,b:2};
    var crr = arr;
    console.log(arr==brr);//false 不同用这种方式判断，除非地址相同
    console.log(arr==crr);//true
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//true

    //局限性--属性的顺序要求一样
    var arr = {a:1,b:2};
    var brr = {b:2,a:2};
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//false
```
>- 采用for-in逐个判断--for-in会遍历原型链所有的可枚举属性
```javascript
    var arr = {a:1,b:2};
    var brr = {b:2,a:1};
    var flag = 1;
    for(const key in arr){
        if(arr[key]!==brr[key]){
            flag = 0;
            break
        }
    }
    console.log(flag?true:false);//true
```

4.移动端适配
1. viewport设置
>- 设置meta····`<meta name='viewport' content='width=device-width,initial-scale=1,user-scale=no,maximum-scale=1.0,minimum-scale=1.0'/>`
>- width设置的是layoutviewport的宽度，initial-scale设置页面的初始缩放值，并且这个初始缩放值是相遇idealviewport缩放的，最终得到的结果不仅会决定viualviewport，还会影响到layoutviewport，user-scalable是否允许用户缩放的设置
2. 小结
>- 适配不同屏幕宽度以及不同dpr，通过动态设置viewport(scale=1/dpr)+根元素+rem，辅助使用vw/vh等来达到适合的显示
>- 若无需适配可显示1px线条，也可以不动态设置scale，只使用动态设置根元素fontSize+rem+理想视口
>- 当视口缩放，计算所得的根元素fontSize也可跟着缩放，即若理想视口(scale=1)，iPhone6根元素fontSize=16px；若scale=0.5，iPhone6根元素fontSize=32px；因此不必担心rem的计算
>- !!css单位：以前我认为这样比较好：适配元素rem为单位，正文字体及边框宜用px为单位；现在认为全部使用rem即可，包括字体大小，不用px
>- px为单位的元素，需根据bpr有不同的大小，如大小12px，dpr=2则采用24px，使用sass mixin简化写法
>- 配合scss函数，简化px2rem转换，且易于维护

5.js的作用域与作用域链
1. 作用域
>- 全局作用域--在代码任何地方都能访问到的对象拥有全局作用域
>- 局部作用域--只有在固定的代码段内可以访问，函数内部，或者一些用let、const定义的变量
>- 1.最外层函数和最外层函数外面定义的变量拥有全局作用域
```javascript
    var outVariable = '最外层变量';
    function outFun() {
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
      }
      innerFun();
    }
    console.log(outVariable);//外层函数
    outFun();//内层变量
    console.log(inVariable);//inVariable is not defined
    innerFun();//innerFun is not defined
```
>- 2.未定义直接赋值，隐性全局变量
```javascript
    function outFun2(){
        variable = '未定义直接赋值'
        var inVariable2 = '内存变量'
    }
    outFun2();//要先支持，否则函数的内容不会创建
    console.log(variable);//未定义直接赋值
    console.log(inVariable2);//inVariable2 is not defined
```
>- 3.所有window对象的属性拥有全局作用域
>- 例如：window.name、window.location、window.top等

>- 4.全局作用域，函数作用域，eval作用域
```javascript
    var a = 10;//全局
    (function(){
        var b = 20;//自调用函数
    })();
    console.log(a);//10
    console.log(b);//b is not defined 
    eval("var c = 1;")//eval
    console.log(c);//1
```
>- 块级作用域
```javascript
    if(true){
        let a = 1
    }

    for(let i=0;i<2;i++){}
    console.log(a);//a is not defined
    console.log(i);//i is not defined
```
2. 作用域链--内部可以访问外部，外部不能访问内部
>- 直接举例子，有点不知道怎么说
```javascript
    var outVariable = '最外层变量';
    function outFun() {//最外层函数
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
        var tempVariable = inVariable;
      }
      innerFun()
    }
    outFun();//内层变量
    console.log(outVariable);//最外层变量
    console.log(inVariable);//inVariable is not defined
    console.log(tempVariable);//tempVariable is not defined
    //作用域链为：
    // window
    // ├──outVariable
    // └──outFun()
    // ├──inVariable
    // └──innerFun()
    //     └──tempVariable
```
3. VO(变量对象)与AO(活动对象)
>- VO用于存储执行上下文中的:1.变量，2.函数声明，3.函数参数
>- VO按照如下顺序填充:1.函数参数(若未传入，初始化该参数值为undefined)，2.函数声明(若发生命名冲突会覆盖),3.变量声明(初始化变量值为undefined，若发生命名冲突，会忽略)
```javascript
    function foo(x, y, z) {
      function x() { }
      console.log(x);
    }
    foo(100);//function x(){}

    function foo2(x, y, z) {
      var x = 50;
      console.log(x);
    }
    foo2(120);//50

    function foo3() {
      function x() { }
      var x = 100;
      console.log(x);
    }
    foo3();//100

    function foo4() {
      function x() { };
      var x;
      console.log(x)
    }
    foo4();//function x(){}
    //注：函数表达式不会影响VO
```
>- 给VO对象内的变量赋值，VO变为AO(活动对象activation object)
```javascript
    console.log(x);//function x(){}
    var x = 10;
    console.log(x);//10
    x = 20;
    function x() { }
    console.log(x);//20

    if (true) {
      var a = 1;
    } else {
      var b = 2;
    }
    console.log(a);//1
    console.log(b);//undefined
```

6.怎么判断一个对象是不是数组
1. 不能使用typeof
>- typeof返回的只有undefined、null、string、number、boolean、object、Symbol、function

2. 构造函数上判断
>- obj.constructor===Array

3. instanceof判断
>- obj instaceof Array;

4. ES5的API，Arraay.isAarry(obj)
```javascript
    var arr = [1,2,3,4];
    console.log(Array.isArray(arr));//true
```

7.js的事件循环机制(event loop)之宏任务/微任务
>- 首先要知道两点
>- JavaScript是单线程、Event Loop是JavaScript的执行机制
1. JavaScript的事件循环
>- js是单线程，任务分为同步任务和异步任务
>- 当我们打开网站时，网页的渲染过程就是一大推同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。
```javascript
    console.log('script start');
    setTimeout(function () {
      console.log('setTimeout');
    }, 0)

    Promise.resolve().then(function () {
      console.log('promise1');
    }).then(function () {
      console.log('promise2');
    })
    console.log('script end');
    //依次打印
    //script start,script end,promise1,promise2,setTimeout
```
>- 为什么会出现这样打印顺序
>- 1. 同步和异步任务分别进入不同的执行“场所”，同步会进入主线程，异步会进入event table并注册函数
>- 2. 当指定的事件完成时，event table会将这个函数移入Event Queue。
>- 3. 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行
>- 4. 上述过程会不断重复，也就是常说的Event Loop(事件循环)
```javascript
    let data = [];
    $.ajax({
        url: www.javascript.com,
        data: data,
        success:()=>{
            console.log('发送成功')
        }
    })
    console.log('执行结束');
    //依次打印
    // ajax进入Event Table，注册回调函数success
    // 执行console.log('执行结束')
    // ajax事件完成，回调函数success进入Event Queue
    // 主线程从Event Queue读取回调函数succes并执行
```
2. 微任务(Microtasks)、宏任务(task)
>- 微任务和宏任务皆为异步任务，它们都属于一个队列，主要却别在于执行顺寻，Event Loop的走向和取值。
>- 有可执行的微任务吗？->有，执行微任务，执行完开始新的宏任务->无，开始新的宏任务
>- 宏任务一般是：包括整体代码script、setTimeout、setInterval。
>- 微任务：原生Promise.then()(有些实现的promise将then方法放到宏任务中)、process.nextTick。

····················································································

## 用友
### 一面
1.es6的继承
>- 具体问题忘了，可参考http://es6.ruanyifeng.com/

2.原型和原型链
1. 原型
>- 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。
>- 原型对象默认拥有一个constructor属性，指向它的构造函数（也就是说构造函数和原型对象的constructor是相互指向的关系）
>- 每个对象都拥有一个隐藏的属性__proto__，指向它的原型对象。这个属性通过Obj.__pro__访问
>- 实际上，构造函数的prototype属性和它创建的实例对象的__proto__指向的是同一个对象，即对象.__proto__ = 函数.prototype。instaceof的底层也是同这个判断的

2. 原型链
>- 访问对象的属性时，JS会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中找。这样的关系就是原型链，原型链指向的最后是Object，Object的__proto__指向null。因此JS中的对象都默认有Object()构造。

3. 介绍个最常用的继承方式--组合继承
```javascript
    function Person(name, age) {
      this.name = name;
      this.age = age;
    }
    Person.prototype.read = function () {
      console.log('read' + this.name)
    }

    function Student(name, age) {
      Person.call(this, name, age);//构造函数继承
    }

    Student.prototype = new Person();

    var per = new Person('人', '100');
    per.read();//read人
    console.dir(per);//Person对象
                      //age: "100"
                      //name: "人"
                      //__proto__: Object

    var stu = new Student('小明', '18');
    stu.read();//read小明
    console.dir(stu);//Student对象
                      // age: "18"
                      // name: "小明"
                      // __proto__: Person
```

3.闭包
1. 概念
>- 闭包就是能够读取到其他函数内部变量的函数，由于js中，只有函数内部的子函数才能读取局部变量。因此可以把闭包理解为“一个函数内部包括内部函数”
>- 本质上，你可以把闭包理解为函数内部和函数外部的一座桥梁。
>- 两大好处：可以读取函数内部的变量、让这些变量的值始终保存在内存中
>-
2. 注意点
>- 由于闭包会使函数中的变量被保存在内存中，内存消耗很大，所有不能滥用闭包，否则会造成性能问题，也可能导致内存泄漏。解决方法是，在退出函数之前，将不适用的局部变量全部删除
>- 闭包会在父函数外部，改变父函数的内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法(Prublic Method)，把内部变量当作它的私有属性(private value)，这时一定要小心，不要随便改变父函数的内部变量的值

3. 例如
```javascript
    function outFun() {
      var a = 1;
      return function inner() {
        a++;
        console.log(a)
      }
    }
    var result1 = outFun();
    result1();//2
    result1();//3
    result1();//4

    var result2 = outFun();
    result2();//2
    //闭包有很多案例，可以找找
```

4.js的事件机制---捕获、冒泡
1. 事件捕获
>- 简单点说，当鼠标点击或触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的事件

2. 事件冒泡
>- 与事件捕获相反，事件冒泡顺序时由内到外进行实际传播，直到根节点

3. 例子
>- 使用div的内嵌，父div嵌套子div
>- 利用addEventListener(event,listener.useCapture)
>- 这里说明一下参数吧
>- 1. event---(事件名称，如click，注意不带on)
>- 2. listener---(事件监听函数)
>- 3. useCapture--(是否采用事件捕获)，默认是false，采用事件冒泡

5.js的事件委托
>- 事件委托是利用事件冒泡的原理实现的，就是事件从最深的节点开始，然后逐步向上传播，举个例子：页面上有这么一个节点树，div>ul>li>a；然后给a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul、li、a做点击事件的时候，都会冒泡到最外层的div上，所以就会触发，这就是事件委托，委托父元素、祖元素代为执行事件

>- 例子
>- 1.点击li即可触发父元素的事件
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(){
            console.log(111)
        })
    }
```
>- 2.点击li准确打印出是··点击了谁
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(event){
        /*
            这里解释一下event.target吧
            Event对象提供了一个属性叫target，可以返回事件的目标节点，我们可以事件源，
            也就是说，target就是表示当前事件操作的dom，但是不是真正操作dom。Event对象
            还有其他属性，感兴趣可以找找
        */
        let target = event.target;
            console.log(target.innerHTML);//点击谁，打印谁的文本
        })
    }
```
>- 总结
>- 什么样的事件可以用事件委托，什么样的事件不可用呢
>- 适合用事件委托的事件：click、mousedown、mouseup、keydown、keyup、keypress
>- 值得注意的是，mouseover和mouserout虽然也有事件冒泡，但是处理他们的时候需要特别的注意，因为需要经常计算他们的位置，处理起来不太容易
>- 不适合的有，mousemove，每次都要计算它的位置，非常不好把控。focus、blur之类的，本身就没有冒泡特性，自然不能用事件委托

6.dom隐藏的方法
>- display:none;---将整个元素隐藏，并且不会占据任何空间
>- visibility:hidden---元素的内容不可见，但是元素仍然保持原来的位置和大小
>- opacity:0---设置透明度为0
>- overflow:hidden--将要隐藏的元素移除父元素的范围

7.深浅拷贝
>- 前面B站一面已经有回答过，这里再说一下深拷贝，以及前面说的深拷贝都是浅拷贝
>- 深拷贝的实现非常复杂，我们需要对需要拷贝的对象进行for-in遍历，对里面每一个元素进行判断(typeof)是引用类型还是基本类型。如果是引用类型需要进一步for-in，基本类型则可以直接赋值。深拷贝就是一个一直迭代的过程，反复判断。最终拷贝原型上的方法，属性也拷贝过来。

8.vue的虚拟dom

9.es6的新特性

10.vue的v-for循环加绑定事件有什么弊端，怎么解决

11.http的请求方式

12.如何做长连接

13.用什么做布局

14.display里面有什么属性值

15.localstorage如何做缓存，保持前后端数据相同

16.http的request和response

17.react学的怎么样，说一下

18.怎么学习前端，有没有系统性的学过

19.其他的记不起来了

## 美团
### 一面
1.JS如何进行事件绑定
>- dom元素上直接绑定
>- JS支持在标签中直接绑定事件，语法：onxxx="JavaScript code"
>- 1.原生函数
```html
    <input type="button" onclick="alert('hello world')" value="点击"/>
```
>- 2.自定义函数
```html
    <input type="button" onclick="func()" value="点击"/>
```
```javascript
    function func(){
        alert("hello world");
    }
```
2.JS代码上绑定
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    document.getElementById('demo').onclick = function(){
        alert('hello world')
    }
```
>- 3.绑定事件监听
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    let demo = document.getElementById('demo');
    demo.addEventListener('click', function () {
        alert('hello world');
  })
```

2.事件委托
>- 上面回答过

3.函数定义
1. 函数声明式
```javascript
    function fun(){}
```
2. 函数表达式
```javascript
    let func = function(){}
```
3. new Function式
```javascript
    //最后传入是函数体，其他都是传入的参数
    let func = new Function('num1','num2','return num1+num2');
    console.log(func(1, 2));//3
```
4. new Function和前面两个的区别
>- 从技术角度上说，使用Function构造函数定义函数的方式是一个函数表达式，不推荐使用这种方式定义函数，因为这个方式会导致两次解析，第一次解析常规的JS代码，第二次解析传入的构造函数的字符串。

4.对this指针的了解

5.call、apply、bind的区别
>- call、apply、bind都可以改变tihs的指向
>- call传入的参数和bind一样，第一个为对象，后面为一个一个的参数，apply第一个传入对象，后面为一个数组
>- call、apply会立即执行，bind不会
>- call、apply会用于构造函数继承

6.如果你实现一个bind，如何实现
>- bind方法会创建一个新函数，当这个新函数被调用时，bind的一个参数将作为它运行的this，之后的一序列参数将会在传递的实参前传入作为它的参数
>- 特点：返回一个函数、可以传入参数
>- 参考：https://juejin.im/post/59093b1fa0bb9f006517b906#heading-1

7.原型和原型链
>- 上面回答过

8.js继承的方法
>- 借用构造函数继承、原型链继承、组合继承、拷贝继承、寄生组合继承、es6的class继承
>- 参考：https://www.cnblogs.com/humin/p/4556820.html

9.盒模型
>- 盒模型由margin、border、padding、(width和height)
>- 标准的盒模型，content就是(width和height)，整个盒子就是margin、border、padding、content。往外涨
>- ie的怪异模型，content是(width和height)、border、padding。整个盒子就是margin、content。外里缩
>- 可以通过box-sizing来设置盒模型尺寸
>- 1. content-box：标准盒模型
>- 2. border-box: 怪异盒模型
>- 3. padding-box：content是(width和height、padding)、border、margin

10.如何解决外边距重叠问题

1. 经典的相邻margin重叠的问题
>- 当一个元素出现在另一个元素上面时，第一个元素的下外边框与第二个元素的上外边框会发送合并
>- 合并的规则：
>- 1.都是正值，去最大
>- 2.一正一负，都绝对值，然后正值减去最大值
>- 3.没有正值，都绝对值，然后0减去最大值
```css
    *{
        margin:0;
        padding: 0;
    }
    .divout{
        width: 100px;
        height: 100px;
        background: yellow;
        margin-bottom: 50px;
        border: 1px solid black;
    }
    .divout1{
        width:50px;
        height: 50px;
        background: yellow;
        margin-top: 80px;
            /*float:left;*/
        /*position:absolute;*/
        border: 1px solid black;
    }
```
```html
    <div class="divout"></div>
    <div class="divout1"></div>
```
>- 解决办法
>- 1. 将元素设置为浮动float:left
>- 2. 在设置margin-top/bottom值时统一设置上或下
>- 3. 元素的position的值设为absolute/fixed

2. 子元素和父元素margin值问题
>- 父元素无border、padding、inline content、clearance时，子元素的margin-top/bottom会与父元素的margin产生重叠的问题
```css
    *{
        margin:0;
        padding: 0;
        color: black;
    }
    #parrent{
        width:300px;
        height:150px;
        margin-top: 20px;
        background:teal;
    }
    #child{
        width:100px;
        height:100px;
        background:aqua;
        margin:100px 0;
    }
```
```html
    <div id="parrent">
        父元素
        <div id="child">
            子元素
        </div>
    </div>
```
>- 解决办法
>- 1. 外层元素padding代替
>- 2. 内层元素透明边框 border:1px solid transparent;
>- 3. 内层元素绝对定位 postion:absolute:
>- 4. 外层元素 overflow:hidden;
>- 5. 内层元素 加float:left;或display:inline-block;
>- 6. 外层元素有边框
>- 注释：只有普通文档流中块框的垂直外边框才会发生外边框并合。行内框、浮动框、绝对定位的外边距不会并合

11.http的请求方式
1. GET--请求指定的页面信息，并返回实体主体
2. HEAD--类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头
3. POST--向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改
4. PUT--从客户端向服务端传送的数据取代指定的文档的内容
5. DELELET--请求服务器删除指定的页面
6. CONNECT--HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
7. OPTIONS--允许客户端查看服务器的性能
8. TRACE--回显服务器收到的请求，主要用于测试或诊断
9. PATCH--是对PUT方法的补充。用于对已知资源进行局部更新

12.options

13.es6的Promise
>- Promise是一个对象，如同其字面意思一样，代表了未来某事件才会知道结果的时间，不受外界因素的影响。Promise一旦触发，其状态只能变为fulfilled或者rejected，并且已经改变不可能逆转。
>- Promise的构造函数接受一个函数作为参数，该参数函数的两个参数分别为resolve和reject，其作用分别是将Promise的状态由pedding转为fulfilled或者rejected，并且将成功或者失败的返回值传递出来。
>- then有两个函数作为Promise状态改变时的回调的过程为异步操作。catch方法时对.then(null,rejectFn)封装(语法糖)。用于指定发生错误时的回调函数。
>- 一般来说，建议不要在then中定义rejected状态的回调函数，应该使用catch方法代替。
>- race和all都是竞速函数，all结束的时间取决与那个最慢，其作为参数的Promise函数一旦有一个状态为rejected，则总的Promise的状态就为rejected；而race结束的时间取决于最快的那个，一旦最快的那个Promise状态发生改变，那个其总的Promise的状态就变成响应的状态，其余的参数Promise还是会继续进行

```javascript
    //基本用法
    let fn = new Promise(function(resolve,reject){
        let num = Math.ceil(Math.random()*10);
        if(num>5){
            resolve(num)
        }else{
            reject(num)
        }
    })
    fn.then((res)=>{
        console.log(res)
    }).catch((err)=>{
        console.log(err)
    })

    //all
    let p1 = Promise.resolve(1),
        p2 = Promise.reject(2),
        p3 = Promise.resolve(3)
    Promise.all([p1,p2,p3]).then((res)=>{
        console.log(res);//不会执行
    }).catch((err)=>{
        console.log(err);//打印2
    })

    //race
    let p1 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('1s');//1s后输出
            resolve(1)
        },1000)
    })
    let p2 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('2s');//2s后输出
        },2000)
    })
    let p5 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('5s');//5s后输出
        },5000)
    })

    Promise.race([p1,p2,p5]).then((res)=>{
        console.log(res);//
    })

```

14.重绘和回流
>- 回流必将引起重绘，重绘不一定会引起回流
1. 回流
>- 当渲染树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流
>- 会导致回流的操作：
>- 1. 页面首次渲染
>- 2. 浏览器窗口大小发生改变
>- 3. 元素尺寸或位置发生改变
>- 4. 元素内容变化（文字数量或图片大小等等）
>- 5. 元素字体大小变化
>- 6. 添加或删除可见的dom元素
>- 7. 激活css伪类（例如 :hover）
>- 8. 查询某些属性或调用某些方法
>- 一些常用且会导致回流的属性和方法
>- 1. clientWidth、clientHeight、clientTop、clientLeft
>- 2. offsetWidth、offsetHeight、offsetTop、offsetLeft
>- 3. scrollWidth、scrollHeight、scrollTop、scroolLeft
>- 4. scrollIntoView()、scroolIntoViewIfNeeded()
>- 5. getComputedStyle()
>- 6. getBoundingClientRect()
>- 7. scrollTo()

2. 重绘
>- 当页面中元素样式的改变并不影响它在文档流中的位置时(例如：color、background-color、visibility等)，浏览器会将样式赋予给元素并重新绘制它，这个过程为重绘

3. 如何避免
>- CSS
>- 1. 避免使用table布局
>- 2. 尽可能在DOM树的最末端改变class
>- 3. 避免设置多层内联样式
>- 4. 将动画效果应用到position属性为absolute或fixed的元素上
>- 5. 避免使用CSS表达式(例如：calc())

>- JavaScript
>- 1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
>- 2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再添加到文档中
>- 3. 也可以先为元素设置display:none，操作结束后再把它显示出来。因为display属性值为none的元素上进行的DOM操作不会引发回流和重绘
>- 4. 避免频繁读取会引发回流/重绘的属性，如果确认需要多次使用，就用一个变量缓存起来
>- 5. 对具有复杂动画的元素使用绝对定位，让它脱离文档流，否则会引起父元素以及后续元素频繁回流

15.跨域
1. 什么是跨域
>- 只要域名、协议、端口有一个不同就是跨域

2. 解决跨域的方法
>- 1.JSONP
>- 原理：利用`<script>`，为了减轻web服务器的负载，把js、css、img等静态分离到另一台独立域名的服务器上，在html页面中通过script标签从不同域名下加载静态资源，而被浏览器允许。我们可以通过动态创建script再请求一个带参网站实现跨域。
>- JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器获取数据的方式，但AJAX属于同源策略，JSONP属于非同源策略(跨域请求)
>- JSONP只能使用get，不能使用post。script不能使用post

```javascript
    let script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = 'http://www.domo.com/login?user=admin&&callback=handleCallback';
        document.head.appendChild(script);
        function handleCallback(res){
            console.log(res);//打印返回数据
    }
```
>- 2.CORS(跨域资源共享)
>- CORS关键是后端，只要后端实现CORS就可以跨域。
>- 服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符*，则表示所有网站都可以访问资源
>- CORS分简单请求和复杂请求
>- 1. 简单请求
>- >- 只要满足以下两大条件，就是简单请求
>- >- 条件1： 使用下列方法之一：
>- >- 1. GET
>- >- 2. HEAD
>- >- 3. POST
>- >- 条件2： Content-Type的值仅限于下列三者之一：
>- >- 1. text/plain
>- >- 2. multipart/form-data
>- >- 3. application/x-www-form-urlencoded
>- 2. 复杂请求
>- >- 不符合以上条件的请求就是复杂请求。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，成为“预检”请求，该请求是option方法的，通过该请求来知道服务器是否允许跨域请求

>- 3.WebSocket
>- WebSocket是HTML5的一个持久化协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方法。WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，WebSocket的server与client都能主动向对方发送或接受数据。同时，WebSocket在建立连接需要借助HTTP协议，连接建立好了之后client与server之间的双向通信就和HTTP无关了
>- 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好低封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容
```javascript
    //script标签中
    let socket = new WebSocket('ws://localhost:3000');
    socket.onopen = function(){
        socket.send('hello world');//向服务器发送数据
    }
    socket.onmessage = function(e){
        console.log(e.data);//接收服务器返回的数据
    }
```
```javascript
    //server.js
    let express = require('express');
    let app = express();
    let webSocket = require('ws');//记得安装ws
    let wss = new webSocket.Server({port:3000});
    wss.on('connection',function(ws){
        ws.on('message',function(data){
            console.log(data);
            ws.send('hello z');
        });
    })
```

>- 4.Node中间件代理(两次跨域)
>- 实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤
>- 1. 接受客户端请求
>- 2. 将请求转发给服务器
>- 3. 拿到服务器响应数据
>- 4. 将响应转发给客户端

>- 5.nginx反向代理
>- 实现原理类似与Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
>- 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能

>- 总结
>- 1. CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
>- 2. JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据
>- 3. 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制
>- 4. 日常工作中，用的比较多的跨域解决方案是CORS和nginx反向代理

16.vue实现轮播，说说思路

17.响应式布局的方法
1. media媒体查询
>- 它根据条件告诉浏览器如何为指定视图宽度渲染页面。假如一个终端的分辨率小于980px
```css
    @media screen and (max-width:980px){
        .header{}
        .content{}
    }
```
2. rem

3. bootstrap的栅栏布局
>- 可以看Bootstrap的官网
```html
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-svalable=no">
    <link rel="stylesheet" type="text/css" href="/stylesheets/bootstrap.min.css">
```

18.canvas
```html
    <canvas width="600" height="400"></canvas>
```
```css
    canvas {
        border: 1px solid #666;
    }
```
```javascript
        //网格上画折线图
        //创建构造函数
        var LineChart = function (ctx) {
            this.ctx = ctx || document.querySelector('canvas').getContext('2d');
            this.canvasWidth = this.ctx.canvas.width;
            this.canvasHeight = this.ctx.canvas.height;
            this.gridSize = 10;//网格大小
            this.space = 20;//原点与边的距离
            this.arrowSize = 10;//箭头大小
            this.dottedSize = 6;//点的大小
            this.x0 = 20;//原点x
            this.y0 = 380;//原点y
        }
        //初始化
        LineChart.prototype.init = function (data) {
            this.drawGrid();//绘制网格
            this.drawAxis();//绘制坐标轴
            this.drawDotted(data);//绘制折线图
        }
        //绘制网格
        LineChart.prototype.drawGrid = function () {
            var xLintTotal = Math.floor(this.canvasHeight / this.gridSize);
            for (let i = 0; i < xLintTotal; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, i * this.gridSize - 0.5);
                this.ctx.lineTo(this.canvasWidth, i * this.gridSize - 0.5);
                this.ctx.strokeStyle = '#ddd'
                this.ctx.stroke()
            }

            var yLintTotal = Math.floor(this.canvasWidth / this.gridSize);
            for (let i = 0; i < yLintTotal; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(i * this.gridSize - 0.5, 0);
                this.ctx.lineTo(i * this.gridSize - 0.5, this.canvasWidth);
                this.ctx.strokeStyle = '#ddd'
                this.ctx.stroke()
            }
        }
        //绘制坐标轴
        LineChart.prototype.drawAxis = function () {
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#000';
            this.ctx.moveTo(this.x0, this.y0);
            this.ctx.lineTo(this.canvasWidth - this.space, this.y0);
            this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 + this.arrowSize / 2)
            this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 - this.arrowSize / 2)
            this.ctx.lineTo(this.canvasWidth - this.space, this.y0)
            this.ctx.stroke();
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#000';
            this.ctx.moveTo(this.x0, this.y0);
            this.ctx.lineTo(this.space, this.space);
            this.ctx.lineTo(this.space + this.arrowSize / 2, this.space + this.arrowSize);
            this.ctx.lineTo(this.space - this.arrowSize / 2, this.space + this.arrowSize);
            this.ctx.lineTo(this.space, this.space);
            this.ctx.stroke();
            this.ctx.fill();

        }
        //绘制折线图
        LineChart.prototype.drawDotted = function (data) {
            var prevCanvasX = this.x0, prevCanvasY = this.y0;
            for (let i = 0; i < data.length; i++) {
                var canvasX = this.x0 + data[i].x;
                var canvasY = this.y0 - data[i].y;
                this.ctx.beginPath();
                this.ctx.moveTo(canvasX - this.dottedSize / 2, canvasY - this.dottedSize / 2);
                this.ctx.lineTo(canvasX + this.dottedSize / 2, canvasY - this.dottedSize / 2);
                this.ctx.lineTo(canvasX + this.dottedSize / 2, canvasY + this.dottedSize / 2);
                this.ctx.lineTo(canvasX - this.dottedSize / 2, canvasY + this.dottedSize / 2);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.moveTo(prevCanvasX, prevCanvasY)
                this.ctx.lineTo(canvasX, canvasY);
                this.ctx.stroke()
                prevCanvasX = canvasX;
                prevCanvasY = canvasY;
            }
        }
        var data = [
            {
                x: 100,
                y: 200,
            },
            {
                x: 130,
                y: 260,
            },
            {
                x: 150,
                y: 210,
            },
            {
                x: 170,
                y: 130,
            },
            {
                x: 270,
                y: 150,
            },
            {
                x: 320,
                y: 230,
            },
            {
                x: 330,
                y: 370,
            },
            {
                x: 370,
                y: 310,
            },
        ]
        let line = new LineChart();
        line.init(data);
```
```javascript
    //100个同心圆
    let myCanvas = document.querySelector('canvas');
    let ctx = myCanvas.getContext('2d');
    let sum = 0;
    for (let i = 0.05; i <= 5; i += 0.05) {
        ctx.beginPath()
        ctx.arc(150, 150, 50 + i * 10, 0, 2 * Math.PI);
        ctx.strokeStyle = randomRgba()
        ctx.stroke();
        sum++
    }
    //产生随机的一个颜色
    function randomRgba() {
        return 'rgba(' + Math.floor(Math.random() * 256) +
        ',' + Math.floor(Math.random() * 256) +
        ',' + Math.floor(Math.random() * 256) +  ',1)'
    }


```
19.其他的记不下来了

## 网易有道
### 一面
1.谈谈html语义化
1. 易于用户阅读、样式丢失的时候让页面呈现清晰的结构
2. 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重
3. 方便其他设备解析，如盲人阅读根据语义渲染网页
4. 有利于开发和维护，语义化更具有可读性，代码更好维护，与css3关系更和谐
5. 用合理、正确的标签来展示内容，比如h1~h6定义标题

2.两列布局和三列布局
1. 两列布局可以采用浮动，定位，flex，gird网格布局
2. 三列布局可以采用浮动，定位，flex，双飞翼、圣杯
这里附上圣杯、双飞翼解释
>- 1.圣杯
>- 借助的是其他非主要元素覆盖其父元素的padding值所占据的宽度，同一个杯子，非主要元素其只是占据了全部容器的padding部分
>- 优点：结构简单，不需要添加dom节点
>- 缺点：圣杯布局的缺点：正常情况下是没有问题的，但是特殊情况下会暴露此布局的弊端，如果将浏览器无线放大时，圣杯将会破碎掉。当main部分的宽小于left部分时就会发生布局混乱
```css
    body{
        min-width: 550px;
    }
    .wrapper{
        overflow: hidden;
        padding: 0 100px;
    }
    .col{
        position: relative;
        float: left;
    }
    .main{
        width: 100%;
        height: 200px;
        background: red;
    }
    .left{
        width: 100px;
        height: 200px;
        margin-left: -100%;
        left: -100px;
        background: yellow
    }
    .right{
        width: 100px;
        height: 200px;
        margin-left: -100px;
        right: -100px;
        background: green;
    }
```
```html
    <body>
        <section class="wrapper">
            <section class="col main">main</section>
            <aside class="col left">left</aside>
            <aside class="col right">right</aside>
        </section>
    </body>
```

>- 2.双飞翼
>- 主要给部分main-wrap添加一个外层main，其他非主要元素所占据的空间是主要部分(main-wrap)的margin空间，像鸟的两个翅膀，与主要部分main脱离
>- 优点：不会像圣杯布局那样变形，支持各种宽高变化、通用性强
>- 缺点:多加了一层dom节点，增加渲染树生成的计算量
```css
    body {
      min-width: 550px
    }
    .col {
      float: left;
    }
    .main {
      width: 100%;
      height: 200px;
      background-color: blue;
    }
    .main-wrapper {
      margin: 0 190px;
    }
    .left,
    .right {
      width: 190px;
      height: 200px;
      background: red;
    }
    .left {
      margin-left: -100%;
    }
    .right {
      margin-left: -190px;
      background-color: yellow;
    }
```
```html
    <body>
        <div class="container">
            <div class="col main">
                <div class="main-wrapper">#main</div>
            </div>
            <div class="col left">#left</div>
            <div class="col right">#right</div>
        </div>
    </body>
```
可参考：https://juejin.im/post/5c88838fe51d4572a74287ee

3.垂直居中的方法
1. 父元素高度确定的单行文本--设置height=line-height
2. 先设置display:table-cell，再设置vertical-align:middle
3. position:absolute(fixed)，设置top:50%,transfom:translateY(-50%);
4. position:absolute(fixed)，margin:auto
5. flex布局，align-items:center

4.盒模型
>- 美团一面时已回答

5.如果两个div，一个左浮动，另一个无浮动会怎么样
>- 比如左浮动，另一个会紧贴前一个，宽度为100%

6.两个都左浮动会怎么样
>- 比如左浮动，两者会紧贴，宽度为自身宽度
>- 5、6可以自己敲下看看~

7.选择器有哪些，权重
>- id选择器(#myid)、类选择器(.myclass)、标签选择器(div)、相邻选择器(h1+p)、子选择器(ul>li)、后代选择器(li a)、通配符(*)、属性选择器(a[rel="external"])、伪类选择器(a:hover)、
>- 权重计算规则：
>- 第一等：代表内联样式，如style=""，权重为1000
>- 第二等：代表id选择器，权重为0100
>- 第三等：代表类、伪类和属性选择器，如.myclass,:hover,a[rel="external"]，权重为0010
>- 第四等：代表类型选择器和伪元素选择器，如div、::after，权重为0001
>- 第五等：代表通配符、相邻选择器、子选择器等，如*，div+p，div>p，权值为0000
>- 继承的样式没有权值
>- !important>第一等>第二等>第三等>第四等>第五等

8.文本超出显示省略号
>- css的text-overflow:ellipsis

9.createElement和createDocumentFragment的区别
>- 在dom操作里，createElement是创建一个新的节点，createDocumentFragment是创建一个文档片段。
>- 参考：https://www.cnblogs.com/xesam/archive/2011/12/19/2293876.html

10.事件委托
>- 用友一面时已回答

11.js基本数据类型
>- B站一面时已回答

12.post和get区别
1. get后退按钮/刷新无害。post数据会被重新提交
2. get能被缓存。post不能被缓存
3. get历史参数会保存在浏览器历史中。post不会
4. get对数据长度有限制，url受限长度为2048个字符。post无限制
5. get安全性较差，暴露在url上，发送敏感信息时绝不使用get。post相对安全，参数不会被保存在浏览器历史或web服务器日志中
6. get数据在url中对所有人都可见，post数据不会显示在url中
7. get一般用于获取数据，post用于提交数据

13.闭包
>- 用友一面已回答

14.状态码301和302的区别
>- 301代表永久性重定向，302代表临时性重定向
1. 什么是重定向
     >- 就是地址A跳转地址B。就是通过各种方法将各种网络请求重新定个方向转到其他位置（如：网页重定向、域名重定向）
2. 为什么要进行重定向
    >- 网站调整（如改变网页目录结构）
    >- 网页被移到一个新地址
    >- 网页扩展名改变（如应用需要把.php改为.html）。这种情况下，如果不做重定向，则用户收藏夹或搜素引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失，再或者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等等

3. 使用301永久性重定向跳转的场景
    >- 域名到期不想续费，或者更换域名
    >- 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向告诉搜索引擎我们目标的域名是哪一个
    >- 空间服务器不稳定，换空间的时候

4. 尽量使用301
    >- 301跳转对查找引擎是一种对照驯良的跳转编制，它告诉查找引擎，这个地址弃用了，永远转向一个新地址，可以转移新域名的权重
    >- 302重定向很容易被搜索引擎误认为是利用多个域名指向同一个网站，那些你的网站就会被疯掉，罪名是”利用重复的内容来感染google搜索结果的网站排名“ 

15.js输出当前时间
```javascript
    let date = new Date()
    let year = date.getFullYear();
    let month = date.getMonth() + 1;//这里注意一下getMonth输出的是0~11
    let day = date.getDate();
    let hour = date.getHours();
    let minute = date.getMinutes();
    let second = date.getSeconds();
    console.log(`${year}-${month}-${day} ${hour}:${minute}:${second}`)
```

16.谈谈你对ajax的理解
1. 不必刷新整个页面，只需要对页面的局部进行更新，可以节省网络宽带，提高页面的加载速度，从而缩短用户的等待时间，改善用户体验
2. 优点：
   >- 无刷新更新数据，减少用户等待时间，更好的用户体验
   >- 异步与服务器通信，无需打断用户，响应更加迅速
   >- 把服务器的一些负担转到客户端，利用客户端闲置的能力来处理，减轻服务器和宽带的负担，节约空间和宽带租用的成本
   >- ajax的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能
   >- 基于标准化，广泛被支持
3. 缺点：
    >- 破坏了前进后退功能，用户往往通过后退按钮取消上一步操作，但是ajax无法实现。
    >- ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远程服务器上建立新的攻击，还有自身受到如跨站脚本攻击，SQL注入等攻击
    >- 对搜索引擎支持较弱
```javascript
    let xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObjct("Microsoft.XMLHTTP");
    xhr.open('url',get,true);
    xhr.send();
    xhr.onreadystatechange = function(){
        if(xhr.status==200&&xhr.readyState==4){
            console.log(xhr.responseText)
        }
    }
    /*
        responseText：响应返回的主体内容，为字符串类型
        responseXML：如果响应类型是"text/xml"或"application/xml"，这个属性中将保存着相应的xml数据，是xml对应的document类型
        status: 响应的HTTP状态码
        statusText：HTTP状态的说明
        readyState：请求/响应过程的当前活动阶段
    */

    /*
        ajax的五个阶段
        0-未初始化，尚未调用open()方法
        1-启动，调用了open()方法，为调用send()方法
        2-发送，已经调用了send()方法，为收到响应
        3-接受，已经接收到部分响应数据
        4-完成，已经接收到全部响应数据
    */
```

17.前端攻击
1. sql注入攻击
>- 就是通过把SQL命令插入到web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL
>- 防范方法:
>- 1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等
>- 2. 永远不要使用动态拼装SQL，可以使用参数化的SQL或直接使用存储过程进行数据查询存取
>- 3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
>- 4. 不要把机密信息明文存放，请加密或hash密码和敏感的信息

2. xss攻击
>- xss(跨站脚本攻击)攻击指的是攻击者往web页面里插入恶意html标签或者javascript代码，比如：攻击者在论讨放一个看似安全的链接骗取用户点击后，窃取cookie中的用户私密信息。或者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点
>- 防范方法:
>- 1. 代码里对用户输入地方和变量都需要仔细检查长度和对">","<",";","'"等字符做过滤；其次任何内容写到页面之前都必须加以`encode`，避免不小心把`html tag`弄出来。这一层做好，至少可以堵住超过一半的xss攻击
>- 2. 避免直接在`cookie`中泄露用户隐私，例如email、密码等
>- 3. 通过`cookie`和系统`ip`绑定来降低`cookie`泄露的危险。这样攻击者得到的`cookie`没有实际价值，不可能拿来重放
>- 4. 尽量采用`post`而非`get`提交表单

3. CSRF攻击
>- CSRF(跨站请求伪造)比起XSS攻击，是另外一种更具危险性的攻击方式，xss是站点用户进行攻击，而CSRF是通过伪装成站点用户进行攻击，而防范的资源也少，难以防范。攻击者盗用用户的身份信息，并以用户名义进行发送恶意的请求等，例如发邮件，盗取账号等非法手段
>- 防范方法：
>- 1. 验证HTTP Referer字段
>- 2. 在请求地址中添加token并验证
>- 3. 在HTTP投中自定义属性验证

4. 网络劫持攻击
5. 钓鱼网站
6. 控制台注入代码

18.webpack的打包过程

19.vuex中的state、mutation、actions
```javascript
/*
    state 保存了组件的数据
    如果要想在组件中使用msg这个数据，最简单的
    直接
        模板中{{$store.state.msg}}
        函数中this.$store.state.msg

        想要好看，则
        computed:{
            msg(){
                return this.$store.state.msg;//其他地方就直接msg就ok
            }
        }
    
    getter 在组件中使用时state方法类似，要把state改成getters
        想要使用reverseMsg
        直接
            模板中{{$store.getters.reverseMsg}}
            函数中this.$store.getters.reverseMsg
        想要好看，则
        computed:{
            reverseMsg:{
                return this.$store.getters.reverseMsg;
            }
        }

    mutation(同步)
        mutation是一个函数，它的作用就是修改state，而且修改state只能通过这一个方式

        我们如果想要组件中对某个数据进行修改，则直接提交对应的mutation即可
        this.$store.commit('setMsg','相关数据');//setMsg是mutation的一个方法

        因为mutation要改变state，所以在mutation中有参数state和载荷payload

    action(异步)
        用法类似与mutation
        一、给mutation传值需要commit
            这是接受的操作
            {
                mutations:{
                    mutation函数(state,payload){
                        //因为mutations改变的是state中的值，所以我们参数中有一个state方便我们快速改变对应的值
                        //payload接受commit处传递过来的数据
                    }
                }
            }
            组件函数中提交mutation，就是给mutation传值
            {
                methods:{
                    函数(){
                        this.$store.commit('mutation函数',数据)
                    }
                }
            }
        二、给action传值需要dispatch
        this.$store.dispatch('action名字',数据)

        因为mutation是同步修改state，所以参数中有state
        但是action是异步获取数据，获取后的数据想要修改到state，因此action中一定要提交mutation去修改state，所以在action的函数中有参数context，这个context就是一个store
        如果想要提交，则context.commit('mutation中的函数名',传的值);
*/
    const store = new Vuex.Store({
        state:{
            msg:'数据'
        },
        getters:{
            reverseMsg(){
                return msg.split('').revese().join('');
            }
        },
        mutations:{
            setMsg(state,payload){
                state.msg = payload
            }
        }
    })

    /*
        在页面中渲染一些数据时，可以把数据放在state中的state
        操作页面元素修改数据时，可以在事件处理函数中this.$store.commit('mutation')，提交mutation 让mutation去修改
        操作页面元素获取新的数据时，可以在事件处理函数中this.$store.dispatch('action')，然后在请求数据成功的时候，让action去commit('mutation')，然后mutations修改数据
        action中代码只涉及到，请求数据 提交mutation
        mutation 只涉及到修改state
        组件中设置到提交mutation或者分发action
    */
```

20.数据去重的方法
```javascript
    //方法一(indexOf直接去重)
    //思路：使用新数组indexOf判断有没有这个元素，没有就添加，最后返回新数组
    function deleteOther(arr) {
      let len = arr.length;
      let brr = [];
      for (let i = 0; i < len; i++) {
        if (brr.indexOf(arr[i]) == -1) {
          brr.push(arr[i])
        }
      }
      return brr;
    }
    let arr = [1, 2, 31, 21, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法二(filter+indexOf索引去重)
    //思路：通过过滤和indexOf，过滤的结果为数据的indexOf和索引相等，不等说明有重复了
    function deleteOther(arr) {
      return Array.prototype.filter.call(arr, (item, index) => {
        return arr.indexOf(item) === index
      })
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法三(相邻去重)
    //思路：先排序，然后相邻比较，不等添加到新数组
    function deleteOther(arr) {
    //   arr.sort(function (a, b) { //也可以这样排序，因为sort会改变数组，返回新数组
    //     return a - b;
    //   })
      var arr = arr.sort(function (a, b) {
        return a - b;
      })
      let brr = [], len = arr.length;
      for (let i = 0; i < len; i++) {
        if (arr[i] !== arr[i - 1]) {
          brr.push(arr[i])
        }
      }
      return brr
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法四(借助对象去重)
    //思路：通过判断对象有没有这个属性，没有则添加并也添加到新数组，最后返回新数组
    function deleteOther(arr) {
      let brr = [], obj = {}, len = arr.length;
      for (let i = 0; i < len; i++) {
        if (!obj[arr[i]]) {
          obj[arr[i]] = 1;
          brr.push(arr[i])
        }
      }
      return brr
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法五(借助es6的Set对象+[...])
    //思路：Set的一个最大特点就是数据不重复，传入数组可以给数组去重，返回Set对象再转为数组
    function deleteOther(arr) {
      return [...new Set(arr)]
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法六(借助es6的Set对象+Array.from())
    //思路：Set的一个最大特点就是数据不重复，传入数组可以给数组去重，返回Set对象再转为数组
    function deleteOther(arr) {
      return Array.from(new Set(arr))
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))
```

21.js数组改变原数组和不改变原数组的方法
1. 改变原数组的方法：
>- push(),pop(),shift(),unshift(),reverse(),sort(),splice()
2. 不改变原数组的方法：
>- concat(),join(),slice(),map(),fliter(),forEach(),every(),some(),find(),indexOf(),lastIndexOf,reduce(),reduceRight(),includes(),split()

22.使用setTimeout实现setInterval
```javascript
// 采用递归的方法
    function mySetInterval() {
        setTimeout(function tick() {
            console.log('tick')
            setTimeout(tick, 1000)
        }, 1000)
     }
```

23.async await
1. async await是generator、promise的语法糖,es7提出的
2. async await必须一起使用
3. async函数返回是Promise对象，这比Generator函数的返回值是Inerator对象方便多了，你可以用then方法指定下一步的操作
4. async函数完成可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖


```javascript
    //使用generator
    function* gen() {
      yield console.log(1)
      yield console.log(2)
      yield console.log(3)
    }
    let ge = gen();
    ge.next();//1
    ge.next();//2
    ge.next();//3

    //promise
    function con(i) {
      return i
    }
    let promise = new Promise(resolve => {
      let data = con(1)
      resolve(data)
    })
    promise.then(res => {
      console.log(res);//1
      return new Promise(resolve => {
        let data = con(2)
        resolve(2)
      })
    }).then(res => {
      console.log(res);//2
      return new Promise(resolve => {
        let data = con(3)
        resolve(3)
      })
    }).then(res => {
      console.log(res);//3
    })

    //async await
    let a = (async () => await 1)()
    let b = (async () => await 2)()
    let c = (async () => await 3)()
    a.then(res => {
      console.log(res)
    })
    b.then(res => {
      console.log(res)
    })
    c.then(res => {
      console.log(res)
    })

```


## 猫眼
### 一面
1.垂直居中的方法
>- 网易有道一面已回答

2.实现三列布局
>- 网易有道一面已回答

3.http缓存
>- http缓存不是必须的，但重用缓存的资源通常是必要的。然而常见的HTTP缓存只能存储GET响应，对于其他类型的响应则无能为力。缓存的关键主要包括request method和目标url（一般只有GET请求才会被缓存）。
>- 普通的缓存案例：
>- 1. 一个检索请求的成功响应：对于GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档、图片、或者文件的响应
>- 2. 永久重定向：响应状态码：301
>- 3. 错误响应：响应状态码：404的一个页面
>- 4. 不完全的响应：响应状态码206，只返回局部的信息
>- 5. 除了GET请求外，如果匹配到作为一个已被定义的cache键名的响应

4.cookie、localstorage、sessionstorage的区别
1. 共同点：保存在浏览器端，且同源
2. 区别：
    >- cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而seessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
    >- cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大的多，可达到5M或者更大
    >- 数据有效期不同，sessionStorage仅在当前浏览器窗口关闭有效，自然也就不可能持久保存，localStorage始终有效，窗口或浏览器关闭也一直保存，因此可做持久数据。cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
    >- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面。localStorage、cookie在所有同源窗口中都是共享的
    >- webStorage支持事件通知机制，可以数据更新的通知发送给监听者。


























