# 面试题--回答仅供参考
## B站
### 一面
1.基本数据类型 Symbol是什么
>- 基本的数据类型有number、string、boolean、null、undefined、Symbol
>- Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值。
>Symbol()函数返回的是Symbol类型的值，该类型具有静态方法和静态属性。
>- Symbol可参考：https://www.jianshu.com/p/425148370333

2.js的深浅拷贝
1. 浅拷贝
>- 引用类型浅拷贝--地址指向相同
>- 把一个数组直接等于另一个数组，这只是把存放的地址拷贝过去，两个指向指的是同一个地址，所以改变其中一个的值，被拷贝也跟着改变。
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr;
    brr[1] = 6
    console.log(arr);//[1,6,2,3,4,5]
    console.log(brr);//[1,6,2,3,4,5]
```
>- 基本数据类型浅拷贝
>- 值在内存中占据这固定大小的空间，并被保存在栈内存中。当一个变量向另一个变量复制基本类型的值，会创建这个值的副本，并且我们不能给基本类型的值添加属性
```javascript
    var a = 1;
    var b = a;
    b.name = '小明';
    console.log(a);//1
    console.log(b);//1
    console.log(b.name);//undefined
    b = 2;
    console.log(a);//1
    console.log(b);//2
```

2. 深拷贝---自身属性、方法改变互不影响
>- 将引用类型的属性、方法拷贝一份给另一个引用类型
>- 用例如下：
>- 使用数组(forEach)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    arr.forEach((item,index)=>{
        brr[index] = item;
    })
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(map)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.map(item=>item)
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(slice)截取--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.slice(0);
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(concat)合并--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.concat();
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用for-in遍历拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    for(const key in arr){
        brr[key] = arr[key]
    }
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- ES6语法...实现深拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [...arr];
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```

3.js怎么判断两个对象相等
>- 采用JSON.stringfy();
```javascript
    var arr = {a:1,b:2};
    var brr = {a:1,b:2};
    var crr = arr;
    console.log(arr==brr);//false 不同用这种方式判断，除非地址相同
    console.log(arr==crr);//true
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//true

    //局限性--属性的顺序要求一样
    var arr = {a:1,b:2};
    var brr = {b:2,a:2};
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//false
```
>- 采用for-in逐个判断--for-in会遍历原型链所有的可枚举属性
```javascript
    var arr = {a:1,b:2};
    var brr = {b:2,a:1};
    var flag = 1;
    for(const key in arr){
        if(arr[key]!==brr[key]){
            flag = 0;
            break
        }
    }
    console.log(flag?true:false);//true
```

4.移动端适配
1. viewport设置
>- 设置meta····`<meta name='viewport' content='width=device-width,initial-scale=1,user-scale=no,maximum-scale=1.0,minimum-scale=1.0'/>`
>- width设置的是layoutviewport的宽度，initial-scale设置页面的初始缩放值，并且这个初始缩放值是相遇idealviewport缩放的，最终得到的结果不仅会决定viualviewport，还会影响到layoutviewport，user-scalable是否允许用户缩放的设置
2. 小结
>- 适配不同屏幕宽度以及不同dpr，通过动态设置viewport(scale=1/dpr)+根元素+rem，辅助使用vw/vh等来达到适合的显示
>- 若无需适配可显示1px线条，也可以不动态设置scale，只使用动态设置根元素fontSize+ren+理想视口
>- 当视口缩放，计算所得的根元素fontSize也可跟着缩放，即若理想视口(scale=1)，iPhone6根元素fontSize=16px；若scale=0.5，iPhone6根元素fontSize=32px；因此不必担心rem的计算
>- !!css单位：以前我认为这样比较好：适配元素rem为单位，正文字体及边框宜用px为单位；现在认为全部使用rem即可，包括字体大小，不用px
>- px为单位的元素，需根据bpr有不同的大小，如大小12px，dpr=2则采用24px，使用sass mixin简化写法
>- 配合scss函数，简化px2rem转换，且易于维护

5.js的作用域与作用域链
1. 作用域
>- 全局作用域--在代码任何地方都能访问到的对象拥有全局作用域
>- 局部作用域--只有在固定的代码段内可以访问，函数内部，或者一些用let、const定义的变量
>- 1. 最外层函数和最外层函数外面定义的变量拥有全局作用域
```javascript
    var outVariable = '最外层变量';
    function outFun() {
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
      }
      innerFun();
    }
    console.log(outVariable);//外层函数
    outFun();//内层变量
    console.log(inVariable);//inVariable is not defined
    innerFun();//innerFun is not defined
```
>- 2.未定义直接赋值，隐性全局变量
```javascript
    function outFun2(){
        variable = '未定义直接赋值'
        var inVariable2 = '内存变量'
    }
    outFun2();//要先支持，否则函数的内容不会创建
    console.log(variable);//未定义直接赋值
    console.log(inVariable2);//inVariable2 is not defined
```
>- 3.所有window对象的属性拥有全局作用域
>- 例如：window.name、window.location、window.top等

>- 4.全局作用域，函数作用域，eval作用域
```javascript
    var a = 10;//全局
    (function(){
        var b = 20;//自调用函数
    })();
    console.log(a);//10
    console.log(b);//b is not defined 
    eval("var c = 1;")//eval
    console.log(c);//1
```
>- 块级作用域
```javascript
if(true){
    let a = 1
}

for(let i=0;i<2;i++){}
console.log(a);//a is not defined
console.log(i);//i is not defined
```
2. 作用域链--内部可以访问外部，外部不能访问内部
>- 直接举例子，有点不知道怎么说
```javascript
    var outVariable = '最外层变量';
    function outFun() {//最外层函数
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
        var tempVariable = inVariable;
      }
      innerFun()
    }
    outFun();//内层变量
    console.log(outVariable);//最外层变量
    console.log(inVariable);//inVariable is not defined
    console.log(tempVariable);//tempVariable is not defined
    //作用域链为：
    // window
    // ├──outVariable
    // └──outFun()
    // ├──inVariable
    // └──innerFun()
    //     └──tempVariable
```
3. VO(变量对象)与AO(活动对象)
>- VO用于存储执行上下文中的:1.变量，2.函数声明，3.函数参数
>- VO按照如下顺序填充:1.函数参数(若未传入，初始化该参数值为undefined)，2.函数声明(若发生命名冲突会覆盖),3.变量声明(初始化变量值为undefined，若发生命名冲突，会忽略)
```javascript
    function foo(x, y, z) {
      function x() { }
      console.log(x);
    }
    foo(100);//function x(){}

    function foo2(x, y, z) {
      var x = 50;
      console.log(x);
    }
    foo2(120);//50

    function foo3() {
      function x() { }
      var x = 100;
      console.log(x);
    }
    foo3();//100

    function foo4() {
      function x() { };
      var x;
      console.log(x)
    }
    foo4();//function x(){}
    //注：函数表达式不会影响VO
```
>- 给VO对象内的变量赋值，VO变为AO(活动对象activation object)
```javascript
    console.log(x);//function x(){}
    var x = 10;
    console.log(x);//10
    x = 20;
    function x() { }
    console.log(x);//20

    if (true) {
      var a = 1;
    } else {
      var b = 2;
    }
    console.log(a);//1
    console.log(b);//undefined
```

6.怎么判断一个对象是不是数组
1. 不能使用typeof
>- typeof返回的只有undefined、null、string、number、boolean、object、Symbol、function

2. 构造函数上判断
>- obj.constructor===Array

3. instanceof判断
>- obj instaceof Array;

4. ES5的API，Arraay.isAarry(obj)
```javascript
    var arr = [1,2,3,4];
    console.log(Array.isArray(arr));//true
```

7.js的事件循环机制(event loop)之宏任务/微任务
>- 首先要知道两点
>- JavaScript是单线程、Event Loop是JavaScript的执行机制
1. JavaScript的事件循环
>- js是单线程，任务分为同步任务和异步任务
>- 当我们打开网站时，网页的渲染过程就是一大推同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。
```javascript
    console.log('script start');
    setTimeout(function () {
      console.log('setTimeout');
    }, 0)

    Promise.resolve().then(function () {
      console.log('promise1');
    }).then(function () {
      console.log('promise2');
    })
    console.log('script end');
    //依次打印
    //script start,script end,promise1,promise2,setTimeout
```
>- 为什么会出现这样打印顺序
>- 1. 同步和异步任务分别进入不同的执行“场所”，同步会进入主线程，异步会进入event table并注册函数
>- 2. 当指定的事件完成时，event table会将这个函数移入Event Queue。
>- 3. 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行
>- 4. 上述过程会不断重复，也就是常说的Event Loop(事件循环)
```javascript
    let data = [];
    $.ajax({
        url: www.javascript.com,
        data: data,
        success:()=>{
            console.log('发送成功')
        }
    })
    console.log('执行结束');
    //依次打印
    // ajax进入Event Table，注册回调函数success
    // 执行console.log('执行结束')
    // ajax事件完成，回调函数success进入Event Queue
    // 主线程从Event Queue读取回调函数succes并执行
```
2. 微任务(Microtasks)、宏任务(task)
>- 微任务和宏任务皆为异步任务，它们都属于一个队列，主要却别在于执行顺寻，Event Loop的走向和取值。
>- 有可执行的微任务吗？->有，执行微任务，执行完开始新的宏任务->无，开始新的宏任务
>- 宏任务一般是：包括整体代码script、setTimeout、setInterval、setlmmediate。
>- 微任务：原生Promise(有些实现的promise将then方法放到宏任务中)、process.nextTick。

····················································································

## 用友
### 一面
1.es6的继承
>- 具体问题忘了，可参考http://es6.ruanyifeng.com/

2.原型和原型链
1. 原型
>- 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。
>- 原型对象默认拥有一个constructor属性，指向它的构造函数（也就是说构造函数和原型对象的constructor是相互指向的关系）
>- 每个对象都拥有一个隐藏的属性(__proto__)，指向它的原型对象。这个属性通过Obj.__pro__访问
>- 实际上，构造函数的prototype属性和它创建的实例对象的__proto__指向的是同一个对象，即对象.__proto__ = 函数.prototype。instaceof的底层也是同这个判断的

2. 原型链
>- 访问对象的属性时，JS会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中找。这样的关系就时原型链，原型链指向的最后时Object，Object的__proto__指向null。因此JS中的对象都默认有Object()构造。

3. 介绍个最常用的继承方式--组合继承
```javascript
    function Person(name, age) {
      this.name = name;
      this.age = age;
    }
    Person.prototype.read = function () {
      console.log('read' + this.name)
    }

    function Student(name, age) {
      Person.call(this, name, age);//构造函数继承
    }

    Student.prototype = new Person();

    var per = new Person('人', '100');
    per.read();//read人
    console.dir(per);//Person对象
                      //age: "100"
                      //name: "人"
                      //__proto__: Object

    var stu = new Student('小明', '18');
    stu.read();//read小明
    console.dir(stu);//Student对象
                      // age: "18"
                      // name: "小明"
                      // __proto__: Person
```

3.闭包
1. 概念
>- 闭包就是能够读取到其他函数内部变量的函数，由于js中，只有函数内部的子函数才能读取局部变量。因此可以把闭包理解为“一个函数内部包括内部函数”
>- 本质上，你可以把闭包理解为函数内部和函数外部的一座桥梁。
>- 两大好处：可以读取函数内部的变量、让这些变量的值始终保存在内存中
>-
2. 注意点
>- 由于闭包会使函数中的变量被保存在内存中，内存消耗很大，所有不能滥用闭包，否则会造成性能问题，也可能导致内存泄漏。解决方法是，在退出函数之前，将不适用的局部变量全部删除
>- 闭包会在父函数外部，改变父函数的内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法(Prublic Method)，把内部变量当作它的私有属性(private value)，这时一定要小心，不要随便改变父函数的内部变量的值

3. 例如
```javascript
    function outFun() {
      var a = 1;
      return function inner() {
        a++;
        console.log(a)
      }
    }
    var result1 = outFun();
    result1();//2
    result1();//3
    result1();//4

    var result2 = outFun();
    result2();//2
    //闭包有很多案例，可以找找
```

4.js的事件机制---捕获、冒泡
1. 事件捕获
>- 简单点说，当鼠标点击或触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的事件

2. 事件冒泡
>- 与事件捕获相反，事件冒泡顺序时由内到外进行实际传播，直到根节点

3. 例子
>- 使用div的内嵌，父div嵌套子div
>- 利用addEventListener(event,listener.useCapture)
>- 这里说明一下参数吧
>- 1. event---(事件名称，如click，注意不带on)
>- 2. listener---(事件监听函数)
>- 3. useCapture--(是否采用事件捕获)，默认是false，采用事件冒泡

5.js的事件委托
>- 事件委托是利用事件冒泡的原理实现的，就是事件从最深的节点开始，然后逐步向上传播，举个例子：页面上有这么一个节点树，div>ul>li>a；然后给a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul、li、a做点击事件的时候，都会冒泡到最外层的div上，所以就会触发，这就是事件委托，委托父元素、祖元素代为执行事件

>- 例子
>- 1.点击li即可触发父元素的事件
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(){
            console.log(111)
        })
    }
```
>- 2.点击li准确打印出是··点击了谁
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(event){
        /*
            这里解释一下event.target吧
            Event对象提供了一个属性叫target，可以返回事件的目标节点，我们可以事件源，
            也就是说，target就是表示当前事件操作的dom，但是不是真正操作dom。Event对象
            还有其他属性，感兴趣可以找找
        */
        let target = event.target;
            console.log(target.innerHTML);//点击谁，打印谁的文本
        })
  }
```
>- 总结
>- 什么样的事件可以用事件委托，什么样的事件不可用呢
>- 适合用事件委托的事件：click、mousedown、mouseup、keydown、keyup、keypress
>- 值得注意的是，mouseover和mouserout虽然也有事件冒泡，但是处理他们的时候需要特别的注意，因为需要经常计算他们的位置，处理起来不太容易
>- 不适合的有，mousemove，每次都要计算它的位置，非常不好把控。focus、blur之类的，本身就没有冒泡特性，自然不能用事件委托

6.dom隐藏的方法
>- display:none;---将整个元素隐藏，并且不会占据任何空间
>- visibility:hidden---元素的内容不可见，但是元素仍然保持原来的位置和大小
>- opacity:0---设置透明度为0
>- overflow:hidden--将要隐藏的元素移除父元素的范围

7.深浅拷贝
>- 前面B站一面已经有回答过，这里再说一下深拷贝，以及前面说的深拷贝都是浅拷贝
>- 深拷贝的实现非常复杂，我们需要对需要拷贝的对象进行for-in遍历，对里面每一个元素进行判断(typeof)是引用类型还是基本类型。如果是引用类型需要进一步for-in，基本类型则可以直接赋值。深拷贝就是一个一直迭代的过程，反复判断。最终拷贝原型上的方法，属性也拷贝过来。

8.vue的虚拟dom

9.es6的新特性

10.vue的v-for循环加绑定事件有什么弊端，怎么解决

11.http的请求方式

12.如何做长连接

13.用什么做布局

14.display里面有什么属性值

15.localstorage如何做缓存，保持前后端数据相同

16.http的request和response

17.react学的怎么样，说一下

18.怎么学习前端，有没有系统性的学过

19.其他的记不起来了

## 美团
### 一面
1.JS如何进行事件绑定
>- dom元素上直接绑定
>- JS支持在标签中直接绑定事件，语法：onxxx="JavaScript code"
>- 1.原生函数
```html
    <input type="button" onclick="alert('hello world')" value="点击"/>
```
>- 2.自定义函数
```html
    <input type="button" onclick="func()" value="点击"/>
```
```javascript
    function func(){
        alert("hello world");
    }
```
2.JS代码上绑定
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    document.getElementById('demo').onclick = function(){
        alert('hello world')
    }
```
>- 3.绑定事件监听
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    let demo = document.getElementById('demo');
    demo.addEventListener('click', function () {
        alert('hello world');
  })
```

2.事件委托
>- 上面回答过

3.函数定义
1. 函数声明式
```javascript
    function fun(){}
```
2. 函数表达式
```javascript
    let func = function(){}
```
3. new Function式
```javascript
    //最后传入是函数体，其他都是传入的参数
    let func = new Function('num1','num2','return num1+num2');
    console.log(func(1, 2));//3
```
4. new Function和前面两个的区别
>- 从技术角度上说，使用Function构造函数定义函数的方式是一个函数表达式，不推荐使用这种方式定义函数，因为这个方式会导致两次解析，第一次解析常规的JS代码，第二次解析传入的构造函数的字符串。

4.对this指针的了解

5.call、apply、bind的区别
>- call、apply、bind都可以改变tihs的指向
>- call传入的参数和bind一样，第一个为对象，后面为一个一个的参数，apply第一个传入对象，后面为一个数组
>- call、apply会立即执行，bind不会
>- call、apply会用于构造函数继承

6.如果你实现一个bind，如何实现
>- bind方法会创建一个新函数，当这个新函数被调用时，bing的一个参数将作为它运行的this，之后的一序列参数将会在传递的实参前传入作为它的参数
>- 特点：返回一个函数、可以传入参数
>- 参考：https://juejin.im/post/59093b1fa0bb9f006517b906#heading-1

7.原型和原型链
>- 上面回答过

8.js继承的方法
>- 借用构造函数继承、原型链继承、组合继承、拷贝继承、寄生组合继承、es6的class继承
>- 参考：https://www.cnblogs.com/humin/p/4556820.html

9.盒模型
>- 盒模型由margin、border、padding、(width和height)
>- 标准的盒模型，content就是(width和height)，整个盒子就是margin、border、padding、content。往外涨
>- ie的怪异模型，content是(width和height)、border、padding。整个盒子就是margin、content。外里缩
>- 可以通过box-sizing来设置盒模型尺寸
>- 1. content-box：标准盒模型
>- 2. border-box: 怪异盒模型
>- 3. padding-box：content是(width和height、padding)、border、margin

10.如何解决外边距重叠问题

1. 经典的相邻margin重叠的问题
>- 当一个元素出现在另一个元素上面时，第一个元素的下外边框与第二个元素的上外边框会发送合并
>- 合并的规则：
>- 1.都是正值，去最大
>- 2.一个一负，都绝对值，然后正值减去最大值
>- 3.没有正值，都绝对值，然后0减去最大值
```css
    *{
        margin:0;
        padding: 0;
    }
    .divout{
        width: 100px;
        height: 100px;
        background: yellow;
        margin-bottom: 50px;
        border: 1px solid black;
    }
    .divout1{
        width:50px;
        height: 50px;
        background: yellow;
        margin-top: 80px;
            /*float:left;*/
        /*position:absolute;*/
        border: 1px solid black;
    }
```
```html
    <div class="divout"></div>
    <div class="divout1"></div>
```
>- 解决办法
>- 1. 将元素设置为浮动float:left
>- 2. 在设置margin-top/bottom值时统一设置上或下
>- 3. 元素的position的值设为absolute/fixed

2. 子元素和父元素margin值问题
>- 父元素无border、padding、inline content、clearance时，子元素的margin-top/bottom会与父元素的margin产生重叠的问题
```css
    *{
        margin:0;
        padding: 0;
        color: black;
    }
    #parrent{
        width:300px;
        height:150px;
        margin-top: 20px;
        background:teal;
    }
    #child{
        width:100px;
        height:100px;
        background:aqua;
        margin:100px 0;
    }
```
```html
    <div id="parrent">
        父元素
        <div id="child">
            子元素
        </div>
    </div>
```
>- 解决办法
>- 1. 外层元素padding代替
>- 2. 内层元素透明边框 border:1px solid transparent;
>- 3. 内层元素绝对定位 postion:absolute:
>- 4. 外层元素 overflow:hidden;
>- 5. 内层元素 加float:left;或display:inline-block;
>- 6. 外层元素有边框
>- 注释：只有普通文档流中块框的垂直外边框才会发生外边框并合。行内框、浮动框、绝对定位的外边距不会并合

11.http的请求方式

12.options

13.es6的promise

14.重绘和回流

15.跨域

16.vue实现轮播，说说思路

17.响应式布局的方法

18.canvas

19.其他的记不下来了












