# 面试题--回答仅供参考
## B站
### 一面
1.基本数据类型 Symbol是什么
>- 基本的数据类型有number、string、boolean、null、undefined、Symbol
>- Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值。
>Symbol()函数返回的是Symbol类型的值，该类型具有静态方法和静态属性。
>- Symbol可参考：https://www.jianshu.com/p/425148370333

2.js的深浅拷贝
1. 浅拷贝
>- 引用类型浅拷贝--地址指向相同
>- 把一个数组直接等于另一个数组，这只是把存放的地址拷贝过去，两个指向指的是同一个地址，所以改变其中一个的值，被拷贝也跟着改变。
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr;
    brr[1] = 6
    console.log(arr);//[1,6,2,3,4,5]
    console.log(brr);//[1,6,2,3,4,5]
```
>- 基本数据类型浅拷贝
>- 值在内存中占据这固定大小的空间，并被保存在栈内存中。当一个变量向另一个变量复制基本类型的值，会创建这个值的副本，并且我们不能给基本类型的值添加属性
```javascript
    var a = 1;
    var b = a;
    b.name = '小明';
    console.log(a);//1
    console.log(b);//1
    console.log(b.name);//undefined
    b = 2;
    console.log(a);//1
    console.log(b);//2
```

2. 深拷贝---自身属性、方法改变互不影响
>- 将引用类型的属性、方法拷贝一份给另一个引用类型
>- 用例如下：
>- 使用数组(forEach)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    arr.forEach((item,index)=>{
        brr[index] = item;
    })
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(map)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.map(item=>item)
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(slice)截取--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.slice(0);
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(concat)合并--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.concat();
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用for-in遍历拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    for(const key in arr){
        brr[key] = arr[key]
    }
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- ES6语法...实现深拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [...arr];
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```

3.js怎么判断两个对象相等
>- 采用JSON.stringfy();
```javascript
    var arr = {a:1,b:2};
    var brr = {a:1,b:2};
    var crr = arr;
    console.log(arr==brr);//false 不同用这种方式判断，除非地址相同
    console.log(arr==crr);//true
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//true

    //局限性--属性的顺序要求一样
    var arr = {a:1,b:2};
    var brr = {b:2,a:2};
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//false
```
>- 采用for-in逐个判断--for-in会遍历原型链所有的可枚举属性
```javascript
    var arr = {a:1,b:2};
    var brr = {b:2,a:1};
    var flag = 1;
    for(const key in arr){
        if(arr[key]!==brr[key]){
            flag = 0;
            break
        }
    }
    console.log(flag?true:false);//true
```

4.移动端适配
1. viewport设置
>- 设置meta····`<meta name='viewport' content='width=device-width,initial-scale=1,user-scale=no,maximum-scale=1.0,minimum-scale=1.0'/>`
>- width设置的是layoutviewport的宽度，initial-scale设置页面的初始缩放值，并且这个初始缩放值是相遇idealviewport缩放的，最终得到的结果不仅会决定viualviewport，还会影响到layoutviewport，user-scalable是否允许用户缩放的设置
2. 小结
>- 适配不同屏幕宽度以及不同dpr，通过动态设置viewport(scale=1/dpr)+根元素+rem，辅助使用vw/vh等来达到适合的显示
>- 若无需适配可显示1px线条，也可以不动态设置scale，只使用动态设置根元素fontSize+ren+理想视口
>- 当视口缩放，计算所得的根元素fontSize也可跟着缩放，即若理想视口(scale=1)，iPhone6根元素fontSize=16px；若scale=0.5，iPhone6根元素fontSize=32px；因此不必担心rem的计算
>- !!css单位：以前我认为这样比较好：适配元素rem为单位，正文字体及边框宜用px为单位；现在认为全部使用rem即可，包括字体大小，不用px
>- px为单位的元素，需根据bpr有不同的大小，如大小12px，dpr=2则采用24px，使用sass mixin简化写法
>- 配合scss函数，简化px2rem转换，且易于维护

5.js的作用域与作用域链
1. 作用域
>- 全局作用域--在代码任何地方都能访问到的对象拥有全局作用域
>- 局部作用域--只有在固定的代码段内可以访问，函数内部，或者一些用let、const定义的变量
>- 1.最外层函数和最外层函数外面定义的变量拥有全局作用域
```javascript
    var outVariable = '最外层变量';
    function outFun() {
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
      }
      innerFun();
    }
    console.log(outVariable);//外层函数
    outFun();//内层变量
    console.log(inVariable);//inVariable is not defined
    innerFun();//innerFun is not defined
```
>- 2.未定义直接赋值，隐性全局变量
```javascript
    function outFun2(){
        variable = '未定义直接赋值'
        var inVariable2 = '内存变量'
    }
    outFun2();//要先支持，否则函数的内容不会创建
    console.log(variable);//未定义直接赋值
    console.log(inVariable2);//inVariable2 is not defined
```
>- 3.所有window对象的属性拥有全局作用域
>- 例如：window.name、window.location、window.top等

>- 4.全局作用域，函数作用域，eval作用域
```javascript
    var a = 10;//全局
    (function(){
        var b = 20;//自调用函数
    })();
    console.log(a);//10
    console.log(b);//b is not defined 
    eval("var c = 1;")//eval
    console.log(c);//1
```
>- 块级作用域
```javascript
    if(true){
        let a = 1
    }

    for(let i=0;i<2;i++){}
    console.log(a);//a is not defined
    console.log(i);//i is not defined
```
2. 作用域链--内部可以访问外部，外部不能访问内部
>- 直接举例子，有点不知道怎么说
```javascript
    var outVariable = '最外层变量';
    function outFun() {//最外层函数
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
        var tempVariable = inVariable;
      }
      innerFun()
    }
    outFun();//内层变量
    console.log(outVariable);//最外层变量
    console.log(inVariable);//inVariable is not defined
    console.log(tempVariable);//tempVariable is not defined
    //作用域链为：
    // window
    // ├──outVariable
    // └──outFun()
    // ├──inVariable
    // └──innerFun()
    //     └──tempVariable
```
3. VO(变量对象)与AO(活动对象)
>- VO用于存储执行上下文中的:1.变量，2.函数声明，3.函数参数
>- VO按照如下顺序填充:1.函数参数(若未传入，初始化该参数值为undefined)，2.函数声明(若发生命名冲突会覆盖),3.变量声明(初始化变量值为undefined，若发生命名冲突，会忽略)
```javascript
    function foo(x, y, z) {
      function x() { }
      console.log(x);
    }
    foo(100);//function x(){}

    function foo2(x, y, z) {
      var x = 50;
      console.log(x);
    }
    foo2(120);//50

    function foo3() {
      function x() { }
      var x = 100;
      console.log(x);
    }
    foo3();//100

    function foo4() {
      function x() { };
      var x;
      console.log(x)
    }
    foo4();//function x(){}
    //注：函数表达式不会影响VO
```
>- 给VO对象内的变量赋值，VO变为AO(活动对象activation object)
```javascript
    console.log(x);//function x(){}
    var x = 10;
    console.log(x);//10
    x = 20;
    function x() { }
    console.log(x);//20

    if (true) {
      var a = 1;
    } else {
      var b = 2;
    }
    console.log(a);//1
    console.log(b);//undefined
```

6.怎么判断一个对象是不是数组
1. 不能使用typeof
>- typeof返回的只有undefined、null、string、number、boolean、object、Symbol、function

2. 构造函数上判断
>- obj.constructor===Array

3. instanceof判断
>- obj instaceof Array;

4. ES5的API，Arraay.isAarry(obj)
```javascript
    var arr = [1,2,3,4];
    console.log(Array.isArray(arr));//true
```

7.js的事件循环机制(event loop)之宏任务/微任务
>- 首先要知道两点
>- JavaScript是单线程、Event Loop是JavaScript的执行机制
1. JavaScript的事件循环
>- js是单线程，任务分为同步任务和异步任务
>- 当我们打开网站时，网页的渲染过程就是一大推同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。
```javascript
    console.log('script start');
    setTimeout(function () {
      console.log('setTimeout');
    }, 0)

    Promise.resolve().then(function () {
      console.log('promise1');
    }).then(function () {
      console.log('promise2');
    })
    console.log('script end');
    //依次打印
    //script start,script end,promise1,promise2,setTimeout
```
>- 为什么会出现这样打印顺序
>- 1. 同步和异步任务分别进入不同的执行“场所”，同步会进入主线程，异步会进入event table并注册函数
>- 2. 当指定的事件完成时，event table会将这个函数移入Event Queue。
>- 3. 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行
>- 4. 上述过程会不断重复，也就是常说的Event Loop(事件循环)
```javascript
    let data = [];
    $.ajax({
        url: www.javascript.com,
        data: data,
        success:()=>{
            console.log('发送成功')
        }
    })
    console.log('执行结束');
    //依次打印
    // ajax进入Event Table，注册回调函数success
    // 执行console.log('执行结束')
    // ajax事件完成，回调函数success进入Event Queue
    // 主线程从Event Queue读取回调函数succes并执行
```
2. 微任务(Microtasks)、宏任务(task)
>- 微任务和宏任务皆为异步任务，它们都属于一个队列，主要却别在于执行顺寻，Event Loop的走向和取值。
>- 有可执行的微任务吗？->有，执行微任务，执行完开始新的宏任务->无，开始新的宏任务
>- 宏任务一般是：包括整体代码script、setTimeout、setInterval、setlmmediate。
>- 微任务：原生Promise(有些实现的promise将then方法放到宏任务中)、process.nextTick。

····················································································

## 用友
### 一面
1.es6的继承
>- 具体问题忘了，可参考http://es6.ruanyifeng.com/

2.原型和原型链
1. 原型
>- 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。
>- 原型对象默认拥有一个constructor属性，指向它的构造函数（也就是说构造函数和原型对象的constructor是相互指向的关系）
>- 每个对象都拥有一个隐藏的属性__proto__，指向它的原型对象。这个属性通过Obj.__pro__访问
>- 实际上，构造函数的prototype属性和它创建的实例对象的__proto__指向的是同一个对象，即对象.__proto__ = 函数.prototype。instaceof的底层也是同这个判断的

2. 原型链
>- 访问对象的属性时，JS会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中找。这样的关系就是原型链，原型链指向的最后是Object，Object的__proto__指向null。因此JS中的对象都默认有Object()构造。

3. 介绍个最常用的继承方式--组合继承
```javascript
    function Person(name, age) {
      this.name = name;
      this.age = age;
    }
    Person.prototype.read = function () {
      console.log('read' + this.name)
    }

    function Student(name, age) {
      Person.call(this, name, age);//构造函数继承
    }

    Student.prototype = new Person();

    var per = new Person('人', '100');
    per.read();//read人
    console.dir(per);//Person对象
                      //age: "100"
                      //name: "人"
                      //__proto__: Object

    var stu = new Student('小明', '18');
    stu.read();//read小明
    console.dir(stu);//Student对象
                      // age: "18"
                      // name: "小明"
                      // __proto__: Person
```

3.闭包
1. 概念
>- 闭包就是能够读取到其他函数内部变量的函数，由于js中，只有函数内部的子函数才能读取局部变量。因此可以把闭包理解为“一个函数内部包括内部函数”
>- 本质上，你可以把闭包理解为函数内部和函数外部的一座桥梁。
>- 两大好处：可以读取函数内部的变量、让这些变量的值始终保存在内存中
>-
2. 注意点
>- 由于闭包会使函数中的变量被保存在内存中，内存消耗很大，所有不能滥用闭包，否则会造成性能问题，也可能导致内存泄漏。解决方法是，在退出函数之前，将不适用的局部变量全部删除
>- 闭包会在父函数外部，改变父函数的内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法(Prublic Method)，把内部变量当作它的私有属性(private value)，这时一定要小心，不要随便改变父函数的内部变量的值

3. 例如
```javascript
    function outFun() {
      var a = 1;
      return function inner() {
        a++;
        console.log(a)
      }
    }
    var result1 = outFun();
    result1();//2
    result1();//3
    result1();//4

    var result2 = outFun();
    result2();//2
    //闭包有很多案例，可以找找
```

4.js的事件机制---捕获、冒泡
1. 事件捕获
>- 简单点说，当鼠标点击或触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的事件

2. 事件冒泡
>- 与事件捕获相反，事件冒泡顺序时由内到外进行实际传播，直到根节点

3. 例子
>- 使用div的内嵌，父div嵌套子div
>- 利用addEventListener(event,listener.useCapture)
>- 这里说明一下参数吧
>- 1. event---(事件名称，如click，注意不带on)
>- 2. listener---(事件监听函数)
>- 3. useCapture--(是否采用事件捕获)，默认是false，采用事件冒泡

5.js的事件委托
>- 事件委托是利用事件冒泡的原理实现的，就是事件从最深的节点开始，然后逐步向上传播，举个例子：页面上有这么一个节点树，div>ul>li>a；然后给a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul、li、a做点击事件的时候，都会冒泡到最外层的div上，所以就会触发，这就是事件委托，委托父元素、祖元素代为执行事件

>- 例子
>- 1.点击li即可触发父元素的事件
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(){
            console.log(111)
        })
    }
```
>- 2.点击li准确打印出是··点击了谁
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(event){
        /*
            这里解释一下event.target吧
            Event对象提供了一个属性叫target，可以返回事件的目标节点，我们可以事件源，
            也就是说，target就是表示当前事件操作的dom，但是不是真正操作dom。Event对象
            还有其他属性，感兴趣可以找找
        */
        let target = event.target;
            console.log(target.innerHTML);//点击谁，打印谁的文本
        })
    }
```
>- 总结
>- 什么样的事件可以用事件委托，什么样的事件不可用呢
>- 适合用事件委托的事件：click、mousedown、mouseup、keydown、keyup、keypress
>- 值得注意的是，mouseover和mouserout虽然也有事件冒泡，但是处理他们的时候需要特别的注意，因为需要经常计算他们的位置，处理起来不太容易
>- 不适合的有，mousemove，每次都要计算它的位置，非常不好把控。focus、blur之类的，本身就没有冒泡特性，自然不能用事件委托

6.dom隐藏的方法
>- display:none;---将整个元素隐藏，并且不会占据任何空间
>- visibility:hidden---元素的内容不可见，但是元素仍然保持原来的位置和大小
>- opacity:0---设置透明度为0
>- overflow:hidden--将要隐藏的元素移除父元素的范围

7.深浅拷贝
>- 前面B站一面已经有回答过，这里再说一下深拷贝，以及前面说的深拷贝都是浅拷贝
>- 深拷贝的实现非常复杂，我们需要对需要拷贝的对象进行for-in遍历，对里面每一个元素进行判断(typeof)是引用类型还是基本类型。如果是引用类型需要进一步for-in，基本类型则可以直接赋值。深拷贝就是一个一直迭代的过程，反复判断。最终拷贝原型上的方法，属性也拷贝过来。

8.vue的虚拟dom

9.es6的新特性

10.vue的v-for循环加绑定事件有什么弊端，怎么解决

11.http的请求方式

12.如何做长连接

13.用什么做布局

14.display里面有什么属性值

15.localstorage如何做缓存，保持前后端数据相同

16.http的request和response

17.react学的怎么样，说一下

18.怎么学习前端，有没有系统性的学过

19.其他的记不起来了

## 美团
### 一面
1.JS如何进行事件绑定
>- dom元素上直接绑定
>- JS支持在标签中直接绑定事件，语法：onxxx="JavaScript code"
>- 1.原生函数
```html
    <input type="button" onclick="alert('hello world')" value="点击"/>
```
>- 2.自定义函数
```html
    <input type="button" onclick="func()" value="点击"/>
```
```javascript
    function func(){
        alert("hello world");
    }
```
2.JS代码上绑定
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    document.getElementById('demo').onclick = function(){
        alert('hello world')
    }
```
>- 3.绑定事件监听
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    let demo = document.getElementById('demo');
    demo.addEventListener('click', function () {
        alert('hello world');
  })
```

2.事件委托
>- 上面回答过

3.函数定义
1. 函数声明式
```javascript
    function fun(){}
```
2. 函数表达式
```javascript
    let func = function(){}
```
3. new Function式
```javascript
    //最后传入是函数体，其他都是传入的参数
    let func = new Function('num1','num2','return num1+num2');
    console.log(func(1, 2));//3
```
4. new Function和前面两个的区别
>- 从技术角度上说，使用Function构造函数定义函数的方式是一个函数表达式，不推荐使用这种方式定义函数，因为这个方式会导致两次解析，第一次解析常规的JS代码，第二次解析传入的构造函数的字符串。

4.对this指针的了解

5.call、apply、bind的区别
>- call、apply、bind都可以改变tihs的指向
>- call传入的参数和bind一样，第一个为对象，后面为一个一个的参数，apply第一个传入对象，后面为一个数组
>- call、apply会立即执行，bind不会
>- call、apply会用于构造函数继承

6.如果你实现一个bind，如何实现
>- bind方法会创建一个新函数，当这个新函数被调用时，bind的一个参数将作为它运行的this，之后的一序列参数将会在传递的实参前传入作为它的参数
>- 特点：返回一个函数、可以传入参数
>- 参考：https://juejin.im/post/59093b1fa0bb9f006517b906#heading-1

7.原型和原型链
>- 上面回答过

8.js继承的方法
>- 借用构造函数继承、原型链继承、组合继承、拷贝继承、寄生组合继承、es6的class继承
>- 参考：https://www.cnblogs.com/humin/p/4556820.html

9.盒模型
>- 盒模型由margin、border、padding、(width和height)
>- 标准的盒模型，content就是(width和height)，整个盒子就是margin、border、padding、content。往外涨
>- ie的怪异模型，content是(width和height)、border、padding。整个盒子就是margin、content。外里缩
>- 可以通过box-sizing来设置盒模型尺寸
>- 1. content-box：标准盒模型
>- 2. border-box: 怪异盒模型
>- 3. padding-box：content是(width和height、padding)、border、margin

10.如何解决外边距重叠问题

1. 经典的相邻margin重叠的问题
>- 当一个元素出现在另一个元素上面时，第一个元素的下外边框与第二个元素的上外边框会发送合并
>- 合并的规则：
>- 1.都是正值，去最大
>- 2.一个一负，都绝对值，然后正值减去最大值
>- 3.没有正值，都绝对值，然后0减去最大值
```css
    *{
        margin:0;
        padding: 0;
    }
    .divout{
        width: 100px;
        height: 100px;
        background: yellow;
        margin-bottom: 50px;
        border: 1px solid black;
    }
    .divout1{
        width:50px;
        height: 50px;
        background: yellow;
        margin-top: 80px;
            /*float:left;*/
        /*position:absolute;*/
        border: 1px solid black;
    }
```
```html
    <div class="divout"></div>
    <div class="divout1"></div>
```
>- 解决办法
>- 1. 将元素设置为浮动float:left
>- 2. 在设置margin-top/bottom值时统一设置上或下
>- 3. 元素的position的值设为absolute/fixed

2. 子元素和父元素margin值问题
>- 父元素无border、padding、inline content、clearance时，子元素的margin-top/bottom会与父元素的margin产生重叠的问题
```css
    *{
        margin:0;
        padding: 0;
        color: black;
    }
    #parrent{
        width:300px;
        height:150px;
        margin-top: 20px;
        background:teal;
    }
    #child{
        width:100px;
        height:100px;
        background:aqua;
        margin:100px 0;
    }
```
```html
    <div id="parrent">
        父元素
        <div id="child">
            子元素
        </div>
    </div>
```
>- 解决办法
>- 1. 外层元素padding代替
>- 2. 内层元素透明边框 border:1px solid transparent;
>- 3. 内层元素绝对定位 postion:absolute:
>- 4. 外层元素 overflow:hidden;
>- 5. 内层元素 加float:left;或display:inline-block;
>- 6. 外层元素有边框
>- 注释：只有普通文档流中块框的垂直外边框才会发生外边框并合。行内框、浮动框、绝对定位的外边距不会并合

11.http的请求方式
1. GET--请求指定的页面信息，并返回实体主体
2. HEAD--类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头
3. POST--向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改
4. PUT--从客户端向服务端传送的数据取代指定的文档的内容
5. DELELET--请求服务器删除指定的页面
6. CONNECT--HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
7. OPTIONS--允许客户端查看服务器的性能
8. TRACE--回显服务器收到的请求，主要用于测试或诊断
9. PATCH--是对PUT方法的补充。用于对已知资源进行局部更新

12.options

13.es6的Promise
>- Promise是一个对象，如同其字面意思一样，代表了未来某事件才会知道结果的时间，不受外界因素的影响。Promise一旦触发，其状态只能变为fulfilled或者rejected，并且已经改变不可能逆转。
>- Promise的构造函数接受一个函数作为参数，该参数函数的两个参数分别为resolve和reject，其作用分别是将Promise的状态由pedding转为fulfilled或者rejected，并且将成功或者失败的返回值传递出来。
>- then有两个函数作为Promise状态改变时的回调的过程为异步操作。catch方法时对.then(null,rejectFn)封装(语法糖)。用于指定发生错误时的回调函数。
>- 一般来说，建议不要在then中定义rejected状态的回调函数，应该使用catch方法代替。
>- race和all都是竞速函数，all结束的时间取决与那个最慢，其作为参数的Promise函数一旦有一个状态为rejected，则总的Promise的状态就为rejected；而race结束的时间取决于最快的那个，一旦最快的那个Promise状态发生改变，那个其总的Promise的状态就变成响应的状态，其余的参数Promise还是会继续进行

```javascript
    //基本用法
    let fn = new Promise(function(resolve,reject){
        let num = Math.ceil(Math.random()*10);
        if(num>5){
            resolve(num)
        }else{
            reject(num)
        }
    })
    fn.then((res)=>{
        console.log(res)
    }).catch((err)=>{
        console.log(err)
    })

    //all
    let p1 = Promise.resolve(1),
        p2 = Promise.reject(2),
        p3 = Promise.resolve(3)
    Promise.all([p1,p2,p3]).then((res)=>{
        console.log(res);//不会执行
    }).catch((err)=>{
        console.log(err);//打印2
    })

    //race
    let p1 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('1s');//1s后输出
            resolve(1)
        },1000)
    })
    let p2 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('2s');//2s后输出
        },2000)
    })
    let p5 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('5s');//5s后输出
        },5000)
    })

    Promise.race([p1,p2,p5]).then((res)=>{
        console.log(res);//
    })

```

14.重绘和回流
>- 回流必将引起重绘，重绘不一定会引起回流
1. 回流
>- 当渲染树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流
>- 会导致回流的操作：
>- 1. 页面首次渲染
>- 2. 浏览器窗口大小发生改变
>- 3. 元素尺寸或位置发生改变
>- 4. 元素内容变化（文字数量或图片大小等等）
>- 5. 元素字体大小变化
>- 6. 添加或删除可见的dom元素
>- 7. 激活css伪类（例如 :hover）
>- 8. 查询某些属性或调用某些方法
>- 一些常用且会导致回流的属性和方法
>- 1. clientWidth、clientHeight、clientTop、clientLeft
>- 2. offsetWidth、offsetHeight、offsetTop、offsetLeft
>- 3. scrollWidth、scrollHeight、scrollTop、scroolLeft
>- 4. scrollIntoView()、scroolIntoViewIfNeeded()
>- 5. getComputedStyle()
>- 6. getBoundingClientRect()
>- 7. scrollTo()

2. 重绘
>- 当页面中元素样式的改变并不影响它在文档流中的位置时(例如：color、background-color、visibility等)，浏览器会将样式赋予给元素并重新绘制它，这个过程为重绘

3. 如何避免
>- CSS
>- 1. 避免使用table布局
>- 2. 尽可能在DOM树的最末端改变class
>- 3. 避免设置多层内联样式
>- 4. 将动画效果应用到position属性为absolute或fixed的元素上
>- 5. 避免使用CSS表达式(例如：calc())

>- JavaScript
>- 1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
>- 2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再添加到文档中
>- 3. 也可以先为元素设置display:none，操作结束后再把它显示出来。因为display属性值为none的元素上进行的DOM操作不会引发回流和重绘
>- 4. 避免频繁读取会引发回流/重绘的属性，如果确认需要多次使用，就用一个变量缓存起来
>- 5. 对具有复杂动画的元素使用绝对定位，让它脱离文档流，否则会引起父元素以及后续元素频繁回流

15.跨域
1. 什么是跨域
>- 只要域名、协议、端口有一个不同就是跨域

2. 解决跨域的方法
>- 1.JSONP
>- 原理：利用`<script>`，为了减轻web服务器的负载，把js、css、img等静态分离到另一台独立域名的服务器上，在html页面中通过script标签从不同域名下加载静态资源，而被浏览器允许。我们可以通过动态创建script再请求一个带参网站实现跨域。
>- JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器获取数据的方式，但AJAX属于同源策略，JSONP属于非同源策略(跨域请求)
>- JSONP只能使用get，不能使用post。script不能使用post

```javascript
    let script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = 'http://www.domo.com/login?user=admin&&callback=handleCallback';
        document.head.appendChild(script);
        function handleCallback(res){
            console.log(res);//打印返回数据
    }
```
>- 2.CORS(跨域资源共享)
>- CORS关键是后端，只要后端实现CORS就可以跨域。
>- 服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符*，则表示所有网站都可以访问资源
>- CORS分简单请求和复杂请求
>- 1. 简单请求
>- >- 只要满足以下两大条件，就是简单请求
>- >- 条件1： 使用下列方法之一：
>- >- 1. GET
>- >- 2. HEAD
>- >- 3. POST
>- >- 条件2： Content-Type的值仅限于下列三者之一：
>- >- 1. text/plain
>- >- 2. multipart/form-data
>- >- 3. application/x-www-form-urlencoded
>- 2. 复杂请求
>- >- 不符合以上条件的请求就是复杂请求。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，成为“预检”请求，该请求是option方法的，通过该请求来知道服务器是否允许跨域请求

>- 3.WebSocket
>- WebSocket是HTML5的一个持久化协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方法。WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，WebSocket的server与client都能主动向对方发送或接受数据。同时，WebSocket在建立连接需要借助HTTP协议，连接建立好了之后client与server之间的双向通信就和HTTP无关了
>- 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好低封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容
```javascript
    //script标签中
    let socket = new WebSocket('ws://localhost:3000');
    socket.onopen = function(){
        socket.send('hello world');//向服务器发送数据
    }
    socket.onmessage = function(e){
        console.log(e.data);//接收服务器返回的数据
    }
```
```javascript
    //server.js
    let express = require('express');
    let app = express();
    let webSocket = require('ws');//记得安装ws
    let wss = new webSocket.Server({port:3000});
    wss.on('connection',function(ws){
        ws.on('message',function(data){
            console.log(data);
            ws.send('hello z');
        });
    })
```

>- 4.Node中间件代理(两次跨域)
>- 实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤
>- 1. 接受客户端请求
>- 2. 将请求转发给服务器
>- 3. 拿到服务器响应数据
>- 4. 将响应转发给客户端

>- 5.nginx反向代理
>- 实现原理类似与Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
>- 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能

>- 总结
>- 1. CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
>- 2. JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据
>- 3. 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制
>- 4. 日常工作中，用的比较多的跨域解决方案是CORS和nginx反向代理

16.vue实现轮播，说说思路

17.响应式布局的方法
1. media媒体查询
>- 它根据条件告诉浏览器如何为指定视图宽度渲染页面。假如一个终端的分辨率小于980px
```css
    @media screen and (max-width:980px){
        .header{}
        .content{}
    }
```
2. rem

3. bootstrap的栅栏布局
>- 可以看Bootstrap的官网
```html
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-svalable=no">
    <link rel="stylesheet" type="text/css" href="/stylesheets/bootstrap.min.css">
```

18.canvas
```html
    <canvas width="600" height="400"></canvas>
```
```css
    canvas {
        border: 1px solid #666;
    }
```
```javascript
        //网格上画折线图
        //创建构造函数
        var LineChart = function (ctx) {
            this.ctx = ctx || document.querySelector('canvas').getContext('2d');
            this.canvasWidth = this.ctx.canvas.width;
            this.canvasHeight = this.ctx.canvas.height;
            this.gridSize = 10;//网格大小
            this.space = 20;//原点与边的距离
            this.arrowSize = 10;//箭头大小
            this.dottedSize = 6;//点的大小
            this.x0 = 20;//原点x
            this.y0 = 380;//原点y
        }
        //初始化
        LineChart.prototype.init = function (data) {
            this.drawGrid();//绘制网格
            this.drawAxis();//绘制网格
            this.drawDotted(data);//绘制折线图
        }
        //绘制网格
        LineChart.prototype.drawGrid = function () {
            var xLintTotal = Math.floor(this.canvasHeight / this.gridSize);
            for (let i = 0; i < xLintTotal; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, i * this.gridSize - 0.5);
                this.ctx.lineTo(this.canvasWidth, i * this.gridSize - 0.5);
                this.ctx.strokeStyle = '#ddd'
                this.ctx.stroke()
            }

            var yLintTotal = Math.floor(this.canvasWidth / this.gridSize);
            for (let i = 0; i < yLintTotal; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(i * this.gridSize - 0.5, 0);
                this.ctx.lineTo(i * this.gridSize - 0.5, this.canvasWidth);
                this.ctx.strokeStyle = '#ddd'
                this.ctx.stroke()
            }
        }
        //绘制网格
        LineChart.prototype.drawAxis = function () {
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#000';
            this.ctx.moveTo(this.x0, this.y0);
            this.ctx.lineTo(this.canvasWidth - this.space, this.y0);
            this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 + this.arrowSize / 2)
            this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 - this.arrowSize / 2)
            this.ctx.lineTo(this.canvasWidth - this.space, this.y0)
            this.ctx.stroke();
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#000';
            this.ctx.moveTo(this.x0, this.y0);
            this.ctx.lineTo(this.space, this.space);
            this.ctx.lineTo(this.space + this.arrowSize / 2, this.space + this.arrowSize);
            this.ctx.lineTo(this.space - this.arrowSize / 2, this.space + this.arrowSize);
            this.ctx.lineTo(this.space, this.space);
            this.ctx.stroke();
            this.ctx.fill();

        }
        //绘制折线图
        LineChart.prototype.drawDotted = function (data) {
            var prevCanvasX = this.x0, prevCanvasY = this.y0;
            for (let i = 0; i < data.length; i++) {
                var canvasX = this.x0 + data[i].x;
                var canvasY = this.y0 - data[i].y;
                this.ctx.beginPath();
                this.ctx.moveTo(canvasX - this.dottedSize / 2, canvasY - this.dottedSize / 2);
                this.ctx.lineTo(canvasX + this.dottedSize / 2, canvasY - this.dottedSize / 2);
                this.ctx.lineTo(canvasX + this.dottedSize / 2, canvasY + this.dottedSize / 2);
                this.ctx.lineTo(canvasX - this.dottedSize / 2, canvasY + this.dottedSize / 2);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.moveTo(prevCanvasX, prevCanvasY)
                this.ctx.lineTo(canvasX, canvasY);
                this.ctx.stroke()
                prevCanvasX = canvasX;
                prevCanvasY = canvasY;
            }
        }
        var data = [
            {
                x: 100,
                y: 200,
            },
            {
                x: 130,
                y: 260,
            },
            {
                x: 150,
                y: 210,
            },
            {
                x: 170,
                y: 130,
            },
            {
                x: 270,
                y: 150,
            },
            {
                x: 320,
                y: 230,
            },
            {
                x: 330,
                y: 370,
            },
            {
                x: 370,
                y: 310,
            },
        ]
        let line = new LineChart();
        line.init(data);
```
```javascript
    //100个同心圆
    let myCanvas = document.querySelector('canvas');
    let ctx = myCanvas.getContext('2d');
    let sum = 0;
    for (let i = 0.05; i <= 5; i += 0.05) {
        ctx.beginPath()
        ctx.arc(150, 150, 50 + i*10, 0, 2 * Math.PI);
        ctx.strokeStyle = '#' + Math.floor(Math.random() * 9) +'f' + Math.floor(Math.random() * 9) + '1' + Math.floor(Math.random() * 9) + 'a';
        ctx.stroke();
        sum++
    }
    console.log(sum)
```


19.其他的记不下来了












