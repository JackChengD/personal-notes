# 面试题--回答仅供参考
## B站
### 一面(问题摘抄)
1.基本数据类型 Symbol是什么
>- 基本的数据类型有number、string、boolean、null、undefined、Symbol
>- Symbol是ES6引入的一种新的原始数据类型，表示独一无二的值。
>Symbol()函数返回的是Symbol类型的值，该类型具有静态方法和静态属性。
>- Symbol可参考：https://www.jianshu.com/p/425148370333

2.js的深浅拷贝
1. 浅拷贝
>- 引用类型浅拷贝--地址指向相同
>- 把一个数组直接等于另一个数组，这只是把存放的地址拷贝过去，两个指向指的是同一个地址，所以改变其中一个的值，被拷贝也跟着改变。
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr;
    brr[1] = 6
    console.log(arr);//[1,6,2,3,4,5]
    console.log(brr);//[1,6,2,3,4,5]
```
>- 基本数据类型浅拷贝
>- 值在内存中占据这固定大小的空间，并被保存在栈内存中。当一个变量向另一个变量复制基本类型的值，会创建这个值的副本，并且我们不能给基本类型的值添加属性
```javascript
    var a = 1;
    var b = a;
    b.name = '小明';
    console.log(a);//1
    console.log(b);//1
    console.log(b.name);//undefined
    b = 2;
    console.log(a);//1
    console.log(b);//2
```

2. 深拷贝---自身属性、方法改变互不影响
>- 将引用类型的属性、方法拷贝一份给另一个引用类型
>- 用例如下：
>- 使用数组(forEach)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    arr.forEach((item,index)=>{
        brr[index] = item;
    })
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(map)遍历赋值
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.map(item=>item)
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(slice)截取--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.slice(0);
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用数组(concat)合并--不会改变原数组
```javascript
    var arr = [1,2,3,4,5];
    var brr = arr.concat();
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- 使用for-in遍历拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [];
    for(const key in arr){
        brr[key] = arr[key]
    }
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```
>- ES6语法...实现深拷贝
```javascript
    var arr = [1,2,3,4,5];
    var brr = [...arr];
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,2,3,4,5]
    brr[1]= 6;
    console.log(arr);//[1,2,3,4,5]
    console.log(brr);//[1,6,3,4,5]
```

3.js怎么判断两个对象相等
>- 采用JSON.stringfy();
```javascript
    var arr = {a:1,b:2};
    var brr = {a:1,b:2};
    var crr = arr;
    console.log(arr==brr);//false 不同用这种方式判断，除非地址相同
    console.log(arr==crr);//true
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//true

    //局限性--属性的顺序要求一样
    var arr = {a:1,b:2};
    var brr = {b:2,a:1};
    console.log(JSON.stringify(arr)==JSON.stringify(brr));//false
```
>- 采用for-in逐个判断--for-in会遍历原型链所有的可枚举属性
```javascript
    var arr = {a:1,b:2};
    var brr = {b:2,a:1};
    var flag = 1;
    for(const key in arr){
        if(arr[key]!==brr[key]){
            flag = 0;
            break
        }
    }
    console.log(flag?true:false);//true
```

4.移动端适配
1. viewport设置
>- 设置meta····`<meta name='viewport' content='width=device-width,initial-scale=1,user-scale=no,maximum-scale=1.0,minimum-scale=1.0'/>`
>- width设置的是layoutviewport的宽度，initial-scale设置页面的初始缩放值，并且这个初始缩放值是相对idealviewport缩放的，最终得到的结果不仅会决定viualviewport，还会影响到layoutviewport，user-scalable是否允许用户缩放的设置
2. 小结
>- 适配不同屏幕宽度以及不同dpr，通过动态设置viewport(scale=1/dpr)+根元素+rem，辅助使用vw/vh等来达到适合的显示
>- 若无需适配可显示1px线条，也可以不动态设置scale，只使用动态设置根元素fontSize+rem+理想视口
>- 当视口缩放，计算所得的根元素fontSize也可跟着缩放，即若理想视口(scale=1)，iPhone6根元素fontSize=16px；若scale=0.5，iPhone6根元素fontSize=32px；因此不必担心rem的计算
>- !!css单位：以前我认为这样比较好：适配元素rem为单位，正文字体及边框宜用px为单位；现在认为全部使用rem即可，包括字体大小，不用px
>- px为单位的元素，需根据bpr有不同的大小，如大小12px，dpr=2则采用24px，使用sass mixin简化写法
>- 配合scss函数，简化px2rem转换，且易于维护

5.js的作用域与作用域链
1. 作用域
>- 全局作用域--在代码任何地方都能访问到的对象拥有全局作用域
>- 局部作用域--只有在固定的代码段内可以访问，函数内部，或者一些用let、const定义的变量
>- 1.最外层函数和最外层函数外面定义的变量拥有全局作用域
```javascript
    var outVariable = '最外层变量';
    function outFun() {
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
      }
      innerFun();
    }
    console.log(outVariable);//最外层变量
    outFun();//内层变量
    console.log(inVariable);//inVariable is not defined
    innerFun();//innerFun is not defined
```
>- 2.未定义直接赋值，隐性全局变量
```javascript
    function outFun2(){
        variable = '未定义直接赋值'
        var inVariable2 = '内存变量'
    }
    outFun2();//要先支持，否则函数的内容不会创建
    console.log(variable);//未定义直接赋值
    console.log(inVariable2);//inVariable2 is not defined
```
>- 3.所有window对象的属性拥有全局作用域
>- 例如：window.name、window.location、window.top等

>- 4.全局作用域，函数作用域，eval作用域
```javascript
    var a = 10;//全局
    (function(){
        var b = 20;//自调用函数
        c = 3;//隐私全局变量，外部可以访问
    })();
    console.log(a);//10
    console.log(b);//b is not defined 
    console.log(c);//3
```
>- 块级作用域
```javascript
    if(true){
        let a = 1
    }

    for(let i=0;i<2;i++){}
    console.log(a);//a is not defined
    console.log(i);//i is not defined
```
2. 作用域链--内部可以访问外部，外部不能访问内部
>- 直接举例子，有点不知道怎么说
```javascript
    var outVariable = '最外层变量';
    function outFun() {//最外层函数
      var inVariable = '内层变量';
      function innerFun() {//内层函数
        console.log(inVariable);
        var tempVariable = inVariable;
      }
      innerFun()
    }
    outFun();//内层变量
    console.log(outVariable);//最外层变量
    console.log(inVariable);//inVariable is not defined
    console.log(tempVariable);//tempVariable is not defined
    //作用域链为：
    // window
    // ├──outVariable
    // └──outFun()
    // ├──inVariable
    // └──innerFun()
    //     └──tempVariable
```
3. VO(变量对象)与AO(活动对象)
>- VO用于存储执行上下文中的:1.变量，2.函数声明，3.函数参数
>- VO按照如下顺序填充:1.函数参数(若未传入，初始化该参数值为undefined)，2.函数声明(若发生命名冲突会覆盖),3.变量声明(初始化变量值为undefined，若发生命名冲突，会忽略)
```javascript
    function foo(x, y, z) {
      function x() { }
      console.log(x);
    }
    foo(100);//function x(){}

    function foo2(x, y, z) {
      var x = 50;
      console.log(x);
    }
    foo2(120);//50

    function foo3() {
      function x() { }
      var x = 100;
      console.log(x);
    }
    foo3();//100

    function foo4() {
      function x() { };
      var x;
      console.log(x)
    }
    foo4();//function x(){}
    //注：函数表达式不会影响VO
```
>- 给VO对象内的变量赋值，VO变为AO(活动对象activation object)
```javascript
    console.log(x);//function x(){}
    var x = 10;
    console.log(x);//10
    x = 20;
    function x() { }
    console.log(x);//20

    if (true) {
      var a = 1;
    } else {
      var b = 2;
    }
    console.log(a);//1
    console.log(b);//undefined,变量会提升，赋值在else里面
```

6.怎么判断一个对象是不是数组
1. 不能使用typeof
>- typeof返回的只有undefined、null、string、number、boolean、object、Symbol、function

2. 构造函数上判断
>- obj.constructor===Array

3. instanceof判断
>- obj instaceof Array;

4. ES6的API，Arraay.isAarry(obj)
```javascript
    var arr = [1,2,3,4];
    console.log(Array.isArray(arr));//true
```
5. 这里补充一下真伪数组的转换
```javascript
    //真数组转为伪数组
    let arr = [1, 1, 1, 12, 3,];
    let obj = {}
    Array.prototype.push.apply(obj, arr)
    console.log(obj)

    //伪数组转为真数组,length不能少
    let obj = {
      0: 1, 1: 2, 2: 4, 3: 5, length: 4
    }
    let arr = [];
    arr = Array.prototype.slice.apply(obj);
    console.log(arr)
    let arr1 = [...obj];
    console.log(arr1)
    

```

7.js的事件循环机制(event loop)之宏任务/微任务
>- 首先要知道两点
>- JavaScript是单线程、Event Loop是JavaScript的执行机制
1. JavaScript的事件循环
>- js是单线程，任务分为同步任务和异步任务
>- 当我们打开网站时，网页的渲染过程就是一大推同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。
```javascript
    console.log('script start');
    setTimeout(function () {
      console.log('setTimeout');
    }, 0)

    Promise.resolve().then(function () {
      console.log('promise1');
    }).then(function () {
      console.log('promise2');
    })
    console.log('script end');
    //依次打印
    //script start,script end,promise1,promise2,setTimeout

    console.log('script start')
    async function async1() {
      await async2()
      console.log('async1 end')
    }
    async function async2() {
      console.log('async2 end')
    }
    async1()

    setTimeout(function() {
      console.log('setTimeout')
    }, 0)

    new Promise(resolve => {
      console.log('Promise')
      resolve()
    })
      .then(function() {
        console.log('promise1')
      })
      .then(function() {
        console.log('promise2')
      })
    console.log('script end')
    //依次打印
    //script start,async2 end,Promise,script end,promise1,promise2,async1 end,setTimeout
```

>- 为什么会出现这样打印顺序
>- 1. 同步和异步任务分别进入不同的执行“场所”，同步会进入主线程，异步会进入event table并注册函数
>- 2. 当指定的事件完成时，event table会将这个函数移入Event Queue。
>- 3. 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行
>- 4. 上述过程会不断重复，也就是常说的Event Loop(事件循环)
```javascript
    let data = [];
    $.ajax({
        url: www.javascript.com,
        data: data,
        success:()=>{
            console.log('发送成功')
        }
    })
    console.log('执行结束');
    //依次打印
    // ajax进入Event Table，注册回调函数success
    // 执行console.log('执行结束')
    // ajax事件完成，回调函数success进入Event Queue
    // 主线程从Event Queue读取回调函数succes并执行
```
2. 微任务(Microtasks)、宏任务(task)
>- 微任务和宏任务皆为异步任务，它们都属于一个队列，主要区别在于执行顺序，Event Loop的走向和取值。
>- 有可执行的微任务吗？->有，执行微任务，执行完开始新的宏任务->无，开始新的宏任务
>- 宏任务一般是：包括整体代码script、setTimeout、setInterval。
>- 微任务：原生Promise.then()(有些实现的promise将then方法放到宏任务中)、process.nextTick。  
>- 很多人都有个误区，认为微任务快于宏任务，其实是错误的，因为宏任务中包括script，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务



## 用友
### 一面(30分钟)
1.es6的继承
>- 具体问题忘了，可参考http://es6.ruanyifeng.com/

2.原型和原型链
1. 原型
>- 每一个构造函数都拥有一个prototype属性，这个属性指向一个对象，也就是原型对象。当使用这个构造函数创建实例的时候，prototype属性指向的原型对象就成为实例的原型对象。
>- 原型对象默认拥有一个constructor属性，指向它的构造函数（也就是说构造函数和原型对象的constructor是相互指向的关系）
>- 每个对象都拥有一个隐藏的属性__proto__，指向它的原型对象。这个属性通过Obj.__pro__访问
>- 实际上，构造函数的prototype属性和它创建的实例对象的__proto__指向的是同一个对象，即对象.__proto__ = 函数.prototype。instaceof的底层也是用这个判断的

2. 原型链
>- 访问对象的属性时，JS会首先在对象自身的属性内查找，若没有找到，则会跳转到该对象的原型对象中找。这样的关系就是原型链，原型链指向的最后是Object，Object的__proto__指向null。因此JS中的对象都默认由Object()构造。

3. 介绍个最常用的继承方式--组合继承
```javascript
    function Person(name, age) {
      this.name = name;
      this.age = age;
    }
    Person.prototype.read = function () {
      console.log('read' + this.name)
    }

    function Student(name, age) {
      Person.call(this, name, age);//构造函数继承
    }

    Student.prototype = new Person();

    var per = new Person('人', '100');
    per.read();//read人
    console.dir(per);//Person对象
                      //age: "100"
                      //name: "人"
                      //__proto__: Object

    var stu = new Student('小明', '18');
    stu.read();//read小明
    console.dir(stu);//Student对象
                      // age: "18"
                      // name: "小明"
                      // __proto__: Person


    //es6的class和extends
    //extends内部也是使用prototype来实现继承的
    class Person {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      };
      sayHi() {
        console.log(this.name)
      }
    }

    class Student extends Person {
      constructor(name, age, sex) {
        super(name, age);
        this.sex = sex;
      }
    }
    let per = new Person('小明', 18);
    per.sayHi();//小明
    let stu = new Student('小敏', 12, 321)
    stu.sayHi();//小敏
    console.log(per, stu);
    // Person {name: "小明", age: 18}
    // age: 18
    // name: "小明"
    // __proto__:
      // constructor: class Person
      // sayHi: ƒ sayHi()
      // __proto__: Object
    
    // Student {name: "小敏", age: 12, sex: 321}
      // age: 12
      // name: "小敏"
      // sex: 321
      // __proto__: Person
        // constructor: class Student
        // __proto__:
          // constructor: class Person
          // sayHi: ƒ sayHi()
          // __proto__: Object
```

3.闭包
1. 概念
>- 闭包就是能够读取到其他函数内部变量的函数，由于js中，只有函数内部的子函数才能读取局部变量。因此可以把闭包理解为“一个函数内部包括内部函数”
>- 本质上，你可以把闭包理解为函数内部和函数外部的一座桥梁。
>- 两大好处：可以读取函数内部的变量、让这些变量的值始终保存在内存中
>-
2. 注意点
>- 由于闭包会使函数中的变量被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成性能问题，也可能导致内存泄漏。解决方法是，在退出函数之前，将不适用的局部变量全部删除
>- 闭包会在父函数外部，改变父函数的内部变量的值。所以，如果你把父函数当作对象(object)使用，把闭包当作它的公用方法(Prublic Method)，把内部变量当作它的私有属性(private value)，这时一定要小心，不要随便改变父函数的内部变量的值

1. 例如
```javascript
    function outFun() {
      var a = 1;
      return function inner() {
        a++;
        console.log(a)
      }
    }
    var result1 = outFun();
    result1();//2
    result1();//3
    result1();//4

    var result2 = outFun();
    result2();//2
    //闭包有很多案例，可以找找


    function fun(n,o) {
        console.log(o)
        return {
            fun:function(m){
            return fun(m,n);
            }
        };
    }
    var a = fun(0);  a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?
    //undefined、0、0、0
    var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?
    //undefined、0、1、2
    var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?
    //undefined、0、1、1
```

4.js的事件机制---捕获、冒泡
1. 事件捕获
>- 简单点说，当鼠标点击或触发dom事件时，浏览器会从根节点开始由外到内进行事件传播，即点击子元素，如果父元素通过事件捕获注册了对应的事件的话，会先触发父元素绑定的事件

2. 事件冒泡
>- 与事件捕获相反，事件冒泡顺序时由内到外进行事件传播，直到根节点

3. 执行顺序
>- 捕获 -> 代码顺序事件 -> 冒泡

4. 例子
>- 使用div的内嵌，父div嵌套子div
>- 利用addEventListener(event,listener,useCapture)
>- 这里说明一下参数吧
>- 1. event---(事件名称，如click，注意不带on)
>- 2. listener---(事件监听函数)
>- 3. useCapture--(是否采用事件捕获)，默认是false，采用事件冒泡

5.js的事件委托
>- 事件委托是利用事件冒泡的原理实现的，就是事件从最深的节点开始，然后逐步向上传播，举个例子：页面上有这么一个节点树，div>ul>li>a；然后给a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，需要我们给最外面的div加点击事件，那么里面的ul、li、a做点击事件的时候，都会冒泡到最外层的div上，所以就会触发，这就是事件委托，委托父元素、祖元素代为执行事件

>- 例子
>- 1.点击li即可触发父元素的事件
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(){
            console.log(111)
        })
    }
```
>- 2.点击li准确打印出是··点击了谁
```html
    <ul id="ul1">
        <li>111</li>
        <li>222</li>
        <li>333</li>
        <li>444</li>
    </ul>
```
```javascript
    window.onload= function(){
        let uls = document.getElementById('ul1');
        uls.addEventListener('click',function(event){
        /*
            这里解释一下event.target吧
            Event对象提供了一个属性叫target，可以返回事件的目标节点，也可以叫做事件源，
            也就是说，target就是表示当前事件操作的dom，但是不是真正操作dom。Event对象
            还有其他属性，感兴趣可以找找
        */
            let target = event.target;
            console.log(target.innerHTML);//点击谁，打印谁的文本
        })
    }
```
>- 总结
>- 什么样的事件可以用事件委托，什么样的事件不可用呢
>- 适合用事件委托的事件：click、mousedown、mouseup、keydown、keyup、keypress
>- 值得注意的是，mouseover和mouserout虽然也有事件冒泡，但是处理他们的时候需要特别的注意，因为需要经常计算他们的位置，处理起来不太容易
>- 不适合的有，mousemove，每次都要计算它的位置，非常不好把控。focus、blur之类的，本身就没有冒泡特性，自然不能用事件委托

6.dom隐藏的方法
>- display:none;---将整个元素隐藏，并且不会占据任何空间
>- visibility:hidden---元素的内容不可见，但是元素仍然保持原来的位置和大小
>- opacity:0---设置透明度为0
>- overflow:hidden--将要隐藏的元素移除父元素的范围

7.深浅拷贝
>- 前面B站一面已经有回答过，这里再说一下深拷贝，以及前面说的深拷贝都是浅拷贝
>- 深拷贝的实现非常复杂，我们需要对需要拷贝的对象进行for-in遍历，对里面每一个元素进行判断(typeof)是引用类型还是基本类型。如果是引用类型需要进一步for-in，基本类型则可以直接赋值。深拷贝就是一个一直迭代的过程，反复判断。最终拷贝原型上的方法，属性也拷贝过来。
```javascript
    //Object.assign第一层是深拷贝，之后是浅拷贝，所以不能直接使用Object.assign实现深拷贝

    //使用递归实现深拷贝
    function _deepClone(source) {
        let target;
        if (typeof source === 'object') {//对象和数组的typeof返回值都是object
            target = Array.isArray(source) ? [] : {}
            for (let key in source) {
            if (source.hasOwnProperty(key)) {
                if (typeof source[key] !== 'object') {
                target[key] = source[key]
                } else {
                target[key] = _deepClone(source[key])
                }
            }
            }
        } else {
            target = source
        }
        return target
    }

    //递归
    function fn(newCur, oldCur) {
      for (let key in oldCur) {
        let item = oldCur[key];
        if (item instanceof Array) {
          newCur[key] = []
          fn(newCur[key], item)
        } else if (item instanceof Object) {
          newCur[key] = {};
          fn(newCur[key], item)
        } else {
          newCur[key] = item
        }
      }
    }
    let obj1 = {}
    let obj2 = {
      age: 1,
      name: '达撒',
      say: ['aaa', 'bbb'],
      hi: {
        age: 22,
        name: "打"
      }
    }
    fn(obj1, obj2)
    console.log(obj1)
    obj2.age = 2
    console.log(obj1)
    console.log(obj2)
    //使用jq的extend方法实现深拷贝
    let obj1 = {
      a: 1,
      b: {
        f: {
          g: 1
        }
      },
      c: [1, 2, 3]
    };
    let obj2 = $.extend(true, {}, obj1);
    obj2.b.f.g = 3
    console.log(obj1, obj2)
    // {a: 1, b: {…}, c: Array(3)}
    // a: 1
    // b:
    // f: {g: 1}
    // __proto__: Object
    // c: (3) [1, 2, 3]
    // __proto__: Object
    
    // {a: 1, b: {…}, c: Array(3)}
    // a: 1
    // b:
    // f: {g: 3}
    // __proto__: Object
    // c: (3) [1, 2, 3]
    // __proto__: Object

    //lodash.cloneDeep()实现深拷贝
    let _ = require('lodash');
    let obj1 = {
        a: 1,
        b: { f: { g: 1 } },
        c: [1, 2, 3]
    };
    let obj2 = _.cloneDeep(obj1);



```

8.vue的虚拟dom
>- 虚拟dom是为了解决浏览器性能问题而设计出来的，通过JS来模拟DOM节点实现虚拟dom
>- Diff算法只是为了虚拟DOM比较替换效率更高

9.es6的新特性

10.vue的v-for循环加绑定事件有什么弊端，怎么解决

11.http的请求方式

12.如何做长连接

13.用什么做布局

14.display里面有什么属性值

15.localstorage如何做缓存，保持前后端数据相同

16.http的request和response

17.react学的怎么样，说一下

18.怎么学习前端，有没有系统性的学过

19.其他的记不起来了


### hr面(15分钟)
1.为什么选择来北京

2.为什么学前端

3.期望薪资

4.个人长处和短处

5.有没有挂科

6.学校有没有参加项目，做什么，有什么创新点

7.学校有没有当过班委，做了什么有意义的事情

8.学校有没有加入社团

9.如何看待团队合作，最喜欢和最讨厌的一个方面


## 美团
### 一面(60分钟)
1.JS如何进行事件绑定
>- dom元素上直接绑定
>- JS支持在标签中直接绑定事件，语法：onxxx="JavaScript code"
>- 1.原生函数
```html
    <input type="button" onclick="alert('hello world')" value="点击"/>
```
>- 2.自定义函数
```html
    <input type="button" onclick="func()" value="点击"/>
```
```javascript
    function func(){
        alert("hello world");
    }
```
2.JS代码上绑定
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    document.getElementById('demo').onclick = function(){
        alert('hello world')
    }
```
>- 3.绑定事件监听
```html
    <input id="demo" type="button" value="点击"/>
```
```javascript
    let demo = document.getElementById('demo');
    demo.addEventListener('click', function () {
        alert('hello world');
  })
```

2.事件委托
>- 用友一面时已回答

3.函数定义
1. 函数声明式
```javascript
    function fun(){}
```
2. 函数表达式
```javascript
    let func = function(){}
```
3. new Function式
```javascript
    //最后传入是函数体，其他都是传入的参数
    let func = new Function('num1','num2','return num1+num2');
    console.log(func(1, 2));//3
```
4. new Function和前面两个的区别
>- 从技术角度上说，使用Function构造函数定义函数的方式是一个函数表达式，不推荐使用这种方式定义函数，因为这个方式会导致两次解析，第一次解析常规的JS代码，第二次解析传入的构造函数的字符串。

4.对this指针的了解
>- 全局this是window
>- 箭头函数的this，是定义位置上下文的this
>- call/apply/bind可以改变this指向
>- 构造函数的this是谁调用就是谁


5.call、apply、bind的区别
>- call、apply、bind都可以改变this的指向
>- call传入的参数和bind一样，第一个为对象，后面为一个一个的参数，apply第一个传入对象，后面为一个数组
>- call、apply会立即执行，bind不会
>- call、apply会用于构造函数继承

6.如果你实现一个bind，如何实现
>- bind方法会创建一个新函数，当这个新函数被调用时，bind的一个参数将作为它运行的this，之后的一序列参数将会在传递的实参前传入作为它的参数
>- 特点：返回一个函数、可以传入参数
>- 参考：https://juejin.im/post/59093b1fa0bb9f006517b906#heading-1
```javascript
    function Person(name, age) {
    this.name = name;
    this.age = age;
    }
    Person.mybind = function (obj, ...arg) {
      let self = this
      return function () {
        self.apply(obj, arg)
      }
      // for(val of arg){
      //   obj[val] = this.val;
      // }

    }
    function Student(name, age) {
    Person.mybind(this, name, age)()
    }
    let stu = new Student('小米', 11);
    console.log(stu)

```

7.原型和原型链
>- 上面回答过

8.js继承的方法
>- 借用构造函数继承、原型链继承、组合继承、拷贝继承、寄生组合继承、es6的class继承
>- 参考：https://www.cnblogs.com/humin/p/4556820.html

9.盒模型
>- 盒模型由margin、padding、border、(width和height)
>- 标准的盒模型，content就是(width和height)，整个盒子就是margin、padding、border、content。往外涨
>- ie的怪异模型，content是(width和height)、padding、border。整个盒子就是margin、content。外里缩
>- 可以通过box-sizing来设置盒模型尺寸
>- 1. content-box：标准盒模型
>- 2. border-box: 怪异盒模型
>- 3. padding-box：content是(width和height、padding)、border、margin
>- 4. inherit：继承

10.如何解决外边距重叠问题

1. 经典的相邻margin重叠的问题
>- 当一个元素出现在另一个元素上面时，第一个元素的下外边框与第二个元素的上外边框会发送合并
>- 合并的规则：
>- 1.都是正值，取最大
>- 2.一正一负，然后正值减去负值的绝对值
>- 3.没有正值，都绝对值，然后0减去最大值
```css
    *{
        margin:0;
        padding: 0;
    }
    .divout{
        width: 100px;
        height: 100px;
        background: yellow;
        margin-bottom: 50px;
        border: 1px solid black;
    }
    .divout1{
        width:50px;
        height: 50px;
        background: yellow;
        margin-top: 80px;
            /*float:left;*/
        /*position:absolute;*/
        border: 1px solid black;
    }
```
```html
    <div class="divout"></div>
    <div class="divout1"></div>
```
>- 解决办法
>- 1. 将元素设置为浮动float:left
>- 2. 在设置margin-top/bottom值时统一设置上或下
>- 3. 元素的position的值设为absolute/fixed

2. 子元素和父元素margin值问题
>- 父元素无border、padding、inline content、clearance时，子元素的margin-top/bottom会与父元素的margin产生重叠的问题
```css
    *{
        margin:0;
        padding: 0;
        color: black;
    }
    #parrent{
        width:300px;
        height:150px;
        margin-top: 20px;
        background:teal;
    }
    #child{
        width:100px;
        height:100px;
        background:aqua;
        margin:100px 0;
    }
```
```html
    <div id="parrent">
        父元素
        <div id="child">
            子元素
        </div>
    </div>
```
>- 解决办法
>- 1. 外层元素padding代替
>- 2. 内层元素透明边框 border:1px solid transparent;
>- 3. 内层元素绝对定位 postion:absolute:
>- 4. 外层元素 overflow:hidden;
>- 5. 内层元素 加float:left;或display:inline-block;
>- 6. 外层元素有边框
>- 注释：只有普通文档流中块框的垂直外边框才会发生外边框并合。行内框、浮动框、绝对定位的外边距不会并合

11.http的请求方式
1. GET--请求指定的页面信息，并返回实体主体
2. HEAD--类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头
3. POST--向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改
4. PUT--从客户端向服务端传送的数据取代指定的文档的内容
5. DELELET--请求服务器删除指定的页面
6. CONNECT--HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器
7. OPTIONS--允许客户端查看服务器的性能
8. TRACE--回显服务器收到的请求，主要用于测试或诊断
9. PATCH--是对PUT方法的补充。用于对已知资源进行局部更新

12.options

13.es6的Promise
>- Promise是一个对象，如同其字面意思一样，不管怎么样都会给你一个结果，不受外界因素的影响。Promise新建后就会立即执行，其状态只能变为fulfilled或者rejected，并且已经改变不可能逆转。当我们在构造 Promise的时候，构造函数内部的代码是立即执行的。
>- Promise的构造函数接受一个函数作为参数，该参数函数的两个参数分别为resolve和reject，其作用分别是将Promise的状态由pending转为fulfilled或者rejected，并且将成功或者失败的返回值传递出来。
>- then有两个函数作为Promise状态改变时的回调的过程为异步操作。catch方法是对.then(null,rejectFn)封装(语法糖)。用于指定发生错误时的回调函数。
>- 一般来说，建议不要在then中定义rejected状态的回调函数，应该使用catch方法代替,这样可以处理 Promise 内部发生的错误。catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。
>- race和all都是竞速函数，all结束的时间取决与那个最慢，其作为参数的Promise函数一旦有一个状态为rejected，则总的Promise的状态就为rejected；而race结束的时间取决于最快的那个，一旦最快的那个Promise状态发生改变，那个其总的Promise的状态就变成响应的状态，其余的参数Promise还是会继续进行

```javascript
    //基本用法
    let fn = new Promise(function(resolve,reject){
        let num = Math.ceil(Math.random()*10);
        if(num>5){
            resolve(num)
        }else{
            reject(num)
        }
    })
    fn.then((res)=>{
        console.log(res)
    }).catch((err)=>{
        console.log(err)
    })

    //all
    let p1 = Promise.resolve(1),
        p2 = Promise.reject(2),
        p3 = Promise.resolve(3)
    Promise.all([p1,p2,p3]).then((res)=>{
        console.log(res);//不会执行
    }).catch((err)=>{
        console.log(err);//打印2
    })

    //all手动实现
    //思想：因为all传入的是一个数组，成功返回执行后数组结果,失败返回失败的
    let p1 = Promise.resolve(1);
    let p2 = Promise.resolve(2);
    let p3 = Promise.resolve(3);
    let promises = [p1, p2, p3]

    Promise.myall = function(promises){
      return new Promise((resolve,reject)=>{
        let results = [];
        let len = promises.length;
        let count = 0;
        //for-of用于遍历数组,for-of不能遍历对象，会报错
        //for-in用于遍历对象
        for(const val of promises){
          Promise.resolve(val).then(res=>{
            results[count++] = res;
            if(results.length == len){
                resolve(results)
            }
          },err=>{  
            reject(err)
          })
        }
      })
    }
    console.log(Promise.myall(promises))

    //race
    let p1 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('1s');//1s后输出
            resolve(1)
        },1000)
    })
    let p2 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('2s');//2s后输出
        },2000)
    })
    let p5 = new Promise((resolve)=>{
        setTimeout(()=>{
            console.log('5s');//5s后输出
        },5000)
    })

    Promise.race([p1,p2,p5]).then((res)=>{
        console.log(res);//
    })

```

14.重绘和回流
>- 回流必将引起重绘，重绘不一定会引起回流
1. 回流
>- 当渲染树中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流
>- 会导致回流的操作：
>- 1. 页面首次渲染
>- 2. 浏览器窗口大小发生改变
>- 3. 元素尺寸或位置发生改变
>- 4. 元素内容变化（文字数量或图片大小等等）
>- 5. 元素字体大小变化
>- 6. 添加或删除可见的dom元素
>- 7. 激活css伪类（例如 :hover）
>- 8. 查询某些属性或调用某些方法
>- 一些常用且会导致回流的属性和方法
>- 1. clientWidth、clientHeight、clientTop、clientLeft
>- 2. offsetWidth、offsetHeight、offsetTop、offsetLeft
>- 3. scrollWidth、scrollHeight、scrollTop、scroolLeft
>- 4. scrollIntoView()、scroolIntoViewIfNeeded()
>- 5. getComputedStyle()
>- 6. getBoundingClientRect()
>- 7. scrollTo()

2. 重绘
>- 当页面中元素样式的改变并不影响它在文档流中的位置时(例如：color、background-color、visibility等)，浏览器会将样式赋予给元素并重新绘制它，这个过程为重绘

3. 如何避免
>- CSS
>- 1. 避免使用table布局
>- 2. 尽可能在DOM树的最末端改变class
>- 3. 避免设置多层内联样式
>- 4. 将动画效果应用到position属性为absolute或fixed的元素上
>- 5. 避免使用CSS表达式(例如：calc())

>- JavaScript
>- 1. 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性
>- 2. 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再添加到文档中
>- 3. 也可以先为元素设置display:none，操作结束后再把它显示出来。因为display属性值为none的元素上进行的DOM操作不会引发回流和重绘
>- 4. 避免频繁读取会引发回流/重绘的属性，如果确认需要多次使用，就用一个变量缓存起来
>- 5. 对具有复杂动画的元素使用绝对定位，让它脱离文档流，否则会引起父元素以及后续元素频繁回流

15.跨域
1. 什么是跨域
>- 只要域名、协议、端口有一个不同就是跨域

2. 解决跨域的方法
>- 1.JSONP
>- 原理：利用`<script>`，为了减轻web服务器的负载，把js、css、img等静态分离到另一台独立域名的服务器上，在html页面中通过script标签从不同域名下加载静态资源，而被浏览器允许。我们可以通过动态创建script再请求一个带参网站实现跨域。
>- JSONP和AJAX相同，都是客户端向服务器端发送请求，从服务器获取数据的方式，但AJAX属于同源策略，JSONP属于非同源策略(跨域请求)
>- JSONP只能使用get，不能使用post。script不能使用post

```javascript
    let script = document.createElement('script');
        script.type = 'text/javascript';
        script.src = 'http://www.domo.com/login?user=admin&&callback=handleCallback';
        document.head.appendChild(script);
        function handleCallback(res){
            console.log(res);//打印返回数据
    }
```
>- 2.CORS(跨域资源共享)
>- CORS关键是后端，只要后端实现CORS就可以跨域。
>- 服务器设置Access-Control-Allow-Origin就可以开启CORS。该属性表示哪些域名可以访问资源，如果设置通配符*，则表示所有网站都可以访问资源
>- CORS分简单请求和复杂请求
>- 1. 简单请求
>- >- 只要满足以下两大条件，就是简单请求
>- >- 条件1： 使用下列方法之一：
>- >- 1. GET
>- >- 2. HEAD
>- >- 3. POST
>- >- 条件2： Content-Type的值仅限于下列三者之一：
>- >- 1. text/plain
>- >- 2. multipart/form-data
>- >- 3. application/x-www-form-urlencoded
>- 2. 复杂请求
>- >- 不符合以上条件的请求就是复杂请求。复杂请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，成为“预检”请求，该请求是option方法的，通过该请求来知道服务器是否允许跨域请求

>- 3.WebSocket
>- WebSocket是HTML5的一个持久化协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方法。WebSocket和HTTP都是应用层协议，都基于TCP协议。但是WebSocket是一种双向通信协议，WebSocket的server与client都能主动向对方发送或接受数据。同时，WebSocket在建立连接需要借助HTTP协议，连接建立好了之后client与server之间的双向通信就和HTTP无关了
>- 原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好低封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容
```javascript
    //script标签中
    let socket = new WebSocket('ws://localhost:3000');
    socket.onopen = function(){
        socket.send('hello world');//向服务器发送数据
    }
    socket.onmessage = function(e){
        console.log(e.data);//接收服务器返回的数据
    }
```
```javascript
    //server.js
    let express = require('express');
    let app = express();
    let webSocket = require('ws');//记得安装ws
    let wss = new webSocket.Server({port:3000});
    wss.on('connection',function(ws){
        ws.on('message',function(data){
            console.log(data);
            ws.send('hello');
        });
    })
```

>- 4.Node中间件代理(两次跨域)
>- 实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。代理服务器，需要做以下几个步骤
>- 1. 接受客户端请求
>- 2. 将请求转发给服务器
>- 3. 拿到服务器响应数据
>- 4. 将响应转发给客户端

>- 5.nginx反向代理
>- 实现原理类似与Node中间件代理，需要你搭建一个中转nginx服务器，用于转发请求。
>- 使用nginx反向代理实现跨域，是最简单的跨域方式。只需要修改nginx的配置即可解决跨域问题，支持所有浏览器，支持session，不需要修改任何代码，并且不会影响服务器性能

>- 总结
>- 1. CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案
>- 2. JSONP只支持GET请求，JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据
>- 3. 不管是Node中间件代理还是nginx反向代理，主要是通过同源策略对服务器不加限制
>- 4. 日常工作中，用的比较多的跨域解决方案是CORS和nginx反向代理

16.vue实现轮播，说说思路

17.响应式布局的方法
1. media媒体查询
>- 它根据条件告诉浏览器如何为指定视图宽度渲染页面。假如一个终端的分辨率小于980px
```css
    @media (max-width:980px){
        .header{}
        .content{}
    }
```
2. rem
>- 相比根元素，计算方法，比如根元素为100px，rem为12/100；
>- 一般rem可以写死一个数字，然后通过修改根元素的px来改变各个rem的具体值
>- 比如先固定了rem的值为0.5，当根元素为100px时，rem的px为50px。当根元素为50px，rem的px为25px

3. bootstrap的栅栏布局
>- 可以看Bootstrap的官网
```html
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-svalable=no">
    <link rel="stylesheet" type="text/css" href="/stylesheets/bootstrap.min.css">
```

18.canvas
```html
    <canvas width="600" height="400"></canvas>
```
```css
    canvas {
        border: 1px solid #666;
    }
```
```javascript
        //网格上画折线图
        //创建构造函数
        var LineChart = function (ctx) {
            this.ctx = ctx || document.querySelector('canvas').getContext('2d');
            this.canvasWidth = this.ctx.canvas.width;
            this.canvasHeight = this.ctx.canvas.height;
            this.gridSize = 10;//网格大小
            this.space = 20;//原点与边的距离
            this.arrowSize = 10;//箭头大小
            this.dottedSize = 6;//点的大小
            this.x0 = 20;//原点x
            this.y0 = 380;//原点y
        }
        //初始化
        LineChart.prototype.init = function (data) {
            this.drawGrid();//绘制网格
            this.drawAxis();//绘制坐标轴
            this.drawDotted(data);//绘制折线图
        }
        //绘制网格
        LineChart.prototype.drawGrid = function () {
            var xLintTotal = Math.floor(this.canvasHeight / this.gridSize);
            for (let i = 0; i < xLintTotal; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(0, i * this.gridSize - 0.5);
                this.ctx.lineTo(this.canvasWidth, i * this.gridSize - 0.5);
                this.ctx.strokeStyle = '#ddd'
                this.ctx.stroke()
            }

            var yLintTotal = Math.floor(this.canvasWidth / this.gridSize);
            for (let i = 0; i < yLintTotal; i++) {
                this.ctx.beginPath();
                this.ctx.moveTo(i * this.gridSize - 0.5, 0);
                this.ctx.lineTo(i * this.gridSize - 0.5, this.canvasWidth);
                this.ctx.strokeStyle = '#ddd'
                this.ctx.stroke()
            }
        }
        //绘制坐标轴
        LineChart.prototype.drawAxis = function () {
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#000';
            this.ctx.moveTo(this.x0, this.y0);
            this.ctx.lineTo(this.canvasWidth - this.space, this.y0);
            this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 + this.arrowSize / 2)
            this.ctx.lineTo(this.canvasWidth - this.space - this.arrowSize, this.y0 - this.arrowSize / 2)
            this.ctx.lineTo(this.canvasWidth - this.space, this.y0)
            this.ctx.stroke();
            this.ctx.fill();
            this.ctx.beginPath();
            this.ctx.strokeStyle = '#000';
            this.ctx.moveTo(this.x0, this.y0);
            this.ctx.lineTo(this.space, this.space);
            this.ctx.lineTo(this.space + this.arrowSize / 2, this.space + this.arrowSize);
            this.ctx.lineTo(this.space - this.arrowSize / 2, this.space + this.arrowSize);
            this.ctx.lineTo(this.space, this.space);
            this.ctx.stroke();
            this.ctx.fill();

        }
        //绘制折线图
        LineChart.prototype.drawDotted = function (data) {
            var prevCanvasX = this.x0, prevCanvasY = this.y0;
            for (let i = 0; i < data.length; i++) {
                var canvasX = this.x0 + data[i].x;
                var canvasY = this.y0 - data[i].y;
                this.ctx.beginPath();
                this.ctx.moveTo(canvasX - this.dottedSize / 2, canvasY - this.dottedSize / 2);
                this.ctx.lineTo(canvasX + this.dottedSize / 2, canvasY - this.dottedSize / 2);
                this.ctx.lineTo(canvasX + this.dottedSize / 2, canvasY + this.dottedSize / 2);
                this.ctx.lineTo(canvasX - this.dottedSize / 2, canvasY + this.dottedSize / 2);
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.beginPath();
                this.ctx.moveTo(prevCanvasX, prevCanvasY)
                this.ctx.lineTo(canvasX, canvasY);
                this.ctx.stroke()
                prevCanvasX = canvasX;
                prevCanvasY = canvasY;
            }
        }
        var data = [
            {
                x: 100,
                y: 200,
            },
            {
                x: 130,
                y: 260,
            },
            {
                x: 150,
                y: 210,
            },
            {
                x: 170,
                y: 130,
            },
            {
                x: 270,
                y: 150,
            },
            {
                x: 320,
                y: 230,
            },
            {
                x: 330,
                y: 370,
            },
            {
                x: 370,
                y: 310,
            },
        ]
        let line = new LineChart();
        line.init(data);
```
```javascript
    //100个同心圆
    let myCanvas = document.querySelector('canvas');
    let ctx = myCanvas.getContext('2d');
    let sum = 0;
    for (let i = 0.05; i <= 5; i += 0.05) {
        ctx.beginPath()
        ctx.arc(150, 150, 50 + i * 10, 0, 2 * Math.PI);
        ctx.strokeStyle = randomRgba()
        ctx.stroke();
        sum++
    }
    //产生随机的一个颜色
    function randomRgba() {
        return 'rgba(' + Math.floor(Math.random() * 256) +
        ',' + Math.floor(Math.random() * 256) +
        ',' + Math.floor(Math.random() * 256) +  ',1)'
    }

```
19.其他的记不下来了


### 二面(45分钟)
1.千分符
```javascript
  function fn(str) {
    let result = '';
    while (str.length > 3) {
      result = ',' + str.slice(-3) + result;
      str = str.slice(0, str.length - 3)
    }
    if (str) {
      result = str + result
    }
    return result
  }
```

2.js代码为什么可以压缩
1. 代码被压缩成了一行
2. 去掉了注释
3. 单引号换成双引号，行尾添加分号
4. 减少JS文件体积，加快其传输速度，减小网络传输

3.promise的应用场景
>- 遇到catch会接着执行下面的.then
>- catch是then的语法糖，返回的都是promise对象
```javascript
    function fn() {
      return new Promise((resolve, reject) => {
        let a = Math.random() * 10;
        if (a > 3) {
          resolve(a)
        } else {
          reject(a)
        }
      })
    }
    let promise1 = fn()
    promise1.then(res=>{
      console.log(res,1)
      return fn()
    }).then(res=>{
      console.log(res,2)
      return fn()
    }).then(res=>{
      console.log(res,3)
      return fn()
    }).catch(res=>{
      console.log(res,4)
      return fn()
    }).then(res=>{
      console.log(res,5)
      return fn()
    }).catch(res=>{
      console.log(res,6)
      return fn()
    }).then(res=>{
      console.log(res,7)
      return fn()
    }).catch(res=>{
      console.log(res,8)
      return fn()
    }).then(res=>{
      console.log(res,9)
      return fn()
    }).then(res=>{
      console.log(res,10)
      return fn()
    })
```

4.promise的异常捕获
>- 比如我现在请求一个ajax，如果一秒内没有收到请求，则执行错误的
>- 可以通过promise.race([promise1,promise2])，promise1为请求的数据，promise2为错误的处理。promise2是一秒后才会执行的

5.nextTick()
1. 定义：
>- 在下次DOM更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的DOM。所以就是衍生出了这个获取更新后的DOM的Vue方法。所以放在Vue.nextTick()回调函数中的执行的应该是会对DOM进行操作的js代码。简单理解是：当数据更新了，在dom中渲染后，自动执行该函数获取更新后的dom。（操作更新后的dom）
>- 参考： https://blog.csdn.net/zhouzuoluo/article/details/84752280

6.let、const、var的应用场景
>- 多看多用即可

7.dom倒序的应用场景

8.flex布局
>- 参考：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html

9.promise和async/await

10.Object.defineProperty里面的属性和弊端
>- Object.defineProperty()的作用就是直接在一个对象上定义一个新属性，或者修改一个已经存在的属性Object.defineProperty(obj,prop,desc)。obj需要定义属性的当前对象、prop当前需要定义的属性名、desc属性描述符，都是必传的
>- desc有
>- value-属性对应的值，可以是任意类型的值，默认undefined
>- writable-是否可以被重写，true为可以重写，false不能被重写，默认是false
>- enumerable-是否可以被枚举（使用for..in或Obect.keys()）true可以被枚举，false不能，默认false
>- configurable-是否可以删除目标属性或是否可以再次修改属性的特性，true可以被删除或可以重新设置特性，false不可以被删除或者重新设置，默认是false
>- 设置了get/set方法，不允许使用writable和value这两个属性
>- get-获取属性值的方法
>- set-设置属性值的方法
>- 兼容性-在ie8下只能在DOM对象上使用，尝试在自定义对象使用Object.defineProperty()会报错

11.同源策略
>- 小米一面已回答

12.跨域
>- 美团一面已回答

13.http1.0、http1.1和http2.0的区别
1. http1.0
>- 无状态、无连接

2. http1.1
>- 持久连接
>- 请求管道化
>- 增加缓存处理（新的字段如cache-control）
>- 增加host字段、支持断点传输等

3. http2.0
>- 二进制分帧
>- 多路复用（或连接共享）
>- 头部压缩
>- 服务器推送
>- 参考：https://segmentfault.com/a/1190000013028798?utm_source=tag-newest

14.http和https的区别
1. https协议需要ca证书、费用较高
2. http是超文本传输协议、信息是明文传输，https则是具有安全性的SSL加密传输协议
3. 使用不同的连接方法，端口也不同，http协议的端口是80，https协议的端口是443
4. http的连接很简单，是无状态；https协议是SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议、比http协议安全
5. http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务端都无法验证对方的身份

15.ssl的过程
>- 对所有传输的内容都进行加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密，此外客户端可以验证服务端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份

16.强缓存和协商缓存
>- 猫眼一面已回答

17.computed和watch的区别
>- computed可以用来做购物车的总价计算、watch可以用于表单检验

18.typescript
1. typescript是Microsoft开发和维护的一种面向对象的编程语言
2. 便于开发人员做注释
3. 能帮助开发人员检测出错误并修改
4. typescript工具使重构变得容易、快捷
5. typescript引入了javascript没有的“类”概念
6. typescript引入了模块的概念，可以把声明、数据、函数和类封装在模块中
7. 类型安全功能能在编码期间检测错误，这为开发人员创建了一个更高效的编码和调试过程

19.webpack

20.vuex
>- 网易有道一面已回答

21.css3的变形transform属性
>- translate-位移、scale-缩放、rotate-旋转、skew-倾斜转换

22.原型和原型链
>- 用友一面已回答

23.class
```javascript
  class A{
    //自身
    foo = function(){

    }
    //原型里面
    foo(){
      
    }
  }
```

24.项目难点

25.最近学的技术

26.技术难点



### 三面(25分钟)
1.项目的重点、难点

2.webpack用过什么loader
>- loader让webpack能够去处理那些非JavaScript文件（webpack自身只理解JavaScript）。loader可以将所有类型的文件转换为webpack能够处理的有效模块，然后你就可以利用webpack的打包能力，对他们进行处理

3.webpack的loader的过程

4.如何校验非法用户

5.移动端如何调试

6.数组去重

7.如何获取对象的属性

8.es6为什么要引入块级作用域

9.CSS预处理器做了什么
>- 为CSS增加一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行CSS的编程工作。转化成通俗易懂的话来说就是“用一种专门的编程语言，进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用”。
>- 参考：https://www.cnblogs.com/yanxiaoge/p/11078843.html

10.vue的生命周期，各个阶段具体做了什么

11.数据请求一般在哪个阶段
>- created

12.个人优缺点

13.怎么学习前端

14.为什么要学前端

15.美团大佬的客观评价


## 网易有道
### 一面(问题摘抄)
1.谈谈html语义化
1. 易于用户阅读、样式丢失的时候让页面呈现清晰的结构
2. 有利于SEO，搜索引擎根据标签来确定上下文和各个关键字的权重
3. 方便其他设备解析，如盲人阅读根据语义渲染网页
4. 有利于开发和维护，语义化更具有可读性，代码更好维护，与css3关系更和谐
5. 用合理、正确的标签来展示内容，比如h1~h6定义标题

2.两列布局和三列布局
1. 两列布局可以采用浮动，定位，flex，gird网格布局
2. 三列布局可以采用浮动，定位，flex，双飞翼、圣杯
这里附上圣杯、双飞翼解释
>- 1.圣杯
>- 借助的是其他非主要元素覆盖其父元素的padding值所占据的宽度，同一个杯子，非主要元素其只是占据了全部容器的padding部分
>- 优点：结构简单，不需要添加dom节点
>- 缺点：圣杯布局的缺点：正常情况下是没有问题的，但是特殊情况下会暴露此布局的弊端，如果将浏览器无线放大时，圣杯将会破碎掉。当main部分的宽小于left部分时就会发生布局混乱
```css
    body{
        min-width: 550px;
    }
    .wrapper{
        overflow: hidden;
        padding: 0 100px;
    }
    .col{
        position: relative;
        float: left;
    }
    .main{
        width: 100%;
        height: 200px;
        background: red;
    }
    .left{
        width: 100px;
        height: 200px;
        margin-left: -100%;
        left: -100px;
        background: yellow
    }
    .right{
        width: 100px;
        height: 200px;
        margin-left: -100px;
        right: -100px;
        background: green;
    }
```
```html
    <body>
        <section class="wrapper">
            <section class="col main">main</section>
            <aside class="col left">left</aside>
            <aside class="col right">right</aside>
        </section>
    </body>
```

>- 2.双飞翼
>- 主要给部分main-wrap添加一个外层main，其他非主要元素所占据的空间是主要部分(main-wrap)的margin空间，像鸟的两个翅膀，与主要部分main脱离
>- 优点：不会像圣杯布局那样变形，支持各种宽高变化、通用性强
>- 缺点：多加了一层dom节点，增加渲染树生成的计算量
```css
    body {
      min-width: 550px
    }
    .col {
      float: left;
    }
    .main {
      width: 100%;
      height: 200px;
      background-color: blue;
    }
    .main-wrapper {
      margin: 0 190px;
    }
    .left,
    .right {
      width: 190px;
      height: 200px;
      background: red;
    }
    .left {
      margin-left: -100%;
    }
    .right {
      margin-left: -190px;
      background-color: yellow;
    }
```
```html
    <body>
        <div class="container">
            <div class="col main">
                <div class="main-wrapper">#main</div>
            </div>
            <div class="col left">#left</div>
            <div class="col right">#right</div>
        </div>
    </body>
```
可参考：https://juejin.im/post/5c88838fe51d4572a74287ee

3.垂直居中的方法
1. 父元素高度确定的单行文本--设置height=line-height
2. 先设置display:table-cell，再设置vertical-align:middle
3. position:absolute(fixed)，设置top:50%,transfom:translateY(-50%);
4. position:absolute(fixed)，margin:auto;
5. flex布局，display:flex;align-items:center;
6. diplay:inline-block;vertical-align:middle;

4.盒模型
>- 美团一面时已回答

5.如果两个div，一个左浮动，另一个无浮动会怎么样
>- 比如左浮动，另一个会紧贴前一个，宽度为100%

6.两个都左浮动会怎么样
>- 比如左浮动，两者会紧贴，宽度为自身宽度
>- 5、6可以自己敲下看看~

7.选择器有哪些，权重
>- id选择器(#myid)、类选择器(.myclass)、标签选择器(div)、相邻选择器(h1+p)、子选择器(ul>li)、后代选择器(li a)、通配符(*)、属性选择器(a[rel="external"])、伪类选择器(a:hover)、
>- 权重计算规则：
>- 第一等：代表内联样式，如style=""，权重为1000
>- 第二等：代表id选择器，权重为0100
>- 第三等：代表类、伪类和属性选择器，如.myclass,:hover,a[rel="external"]，权重为0010
>- 第四等：代表类型选择器和伪元素选择器，如div、::after，权重为0001
>- 第五等：代表通配符、相邻选择器、子选择器等，如*，div+p，div>p，权值为0000
>- 继承的样式没有权值
>- !important>第一等>第二等>第三等>第四等>第五等

8.文本超出显示省略号
>- css的text-overflow:ellipsis

9.createElement和createDocumentFragment的区别
>- 在dom操作里，createElement是创建一个新的节点，createDocumentFragment是创建一个文档片段。
>- 参考：https://www.cnblogs.com/xesam/archive/2011/12/19/2293876.html

10.事件委托
>- 用友一面时已回答

11.js基本数据类型
>- B站一面时已回答

12.post和get区别
1. get后退按钮/刷新无害。post数据会被重新提交
2. get能被缓存。post不能被缓存
3. get历史参数会保存在浏览器历史中。post不会
4. get对数据长。rl上，发送敏感信息时绝不使用get。post相对安全，参数不会被保存在浏览器历史或web服务器日志中
6. get数据在url中对所有人都可见，post数据不会显示在url中
7. get一般用于获取数据，post用于提交数据

13.闭包
>- 用友一面已回答

14.状态码301和302的区别
>- 301代表永久性重定向，302代表临时性重定向
1. 什么是重定向
     >- 就是地址A跳转地址B。就是通过各种方法将各种网络请求重新定个方向转到其他位置（如：网页重定向、域名重定向）
2. 为什么要进行重定向
    >- 网站调整（如改变网页目录结构）
    >- 网页被移到一个新地址
    >- 网页扩展名改变（如应用需要把.php改为.html）。这种情况下，如果不做重定向，则用户收藏夹或搜素引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失，再或者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等等

3. 使用301永久性重定向跳转的场景
    >- 域名到期不想续费，或者更换域名
    >- 在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向告诉搜索引擎我们目标的域名是哪一个
    >- 空间服务器不稳定，换空间的时候

4. 尽量使用301
    >- 301跳转对查找引擎是一种对照驯良的跳转编制，它告诉查找引擎，这个地址弃用了，永远转向一个新地址，可以转移新域名的权重
    >- 302重定向很容易被搜索引擎误认为是利用多个域名指向同一个网站，那些你的网站就会被封掉，罪名是“利用重复的内容来感染google搜索结果的网站排名”

15.js输出当前时间
```javascript
    let date = new Date()
    let year = date.getFullYear();
    let month = date.getMonth() + 1;//这里注意一下getMonth输出的是0~11
    let day = date.getDate();
    let hour = date.getHours();
    let minute = date.getMinutes();
    let second = date.getSeconds();
    console.log(`${year}-${month}-${day} ${hour}:${minute}:${second}`)
```

16.谈谈你对ajax的理解
1. 不必刷新整个页面，只需要对页面的局部进行更新，可以节省网络宽带，提高页面的加载速度，从而缩短用户的等待时间，改善用户体验
2. 优点：
   >- 无刷新更新数据，减少用户等待时间，更好的用户体验
   >- 异步与服务器通信，无需打断用户，响应更加迅速
   >- 把服务器的一些负担转到客户端，利用客户端闲置的能力来处理，减轻服务器和宽带的负担，节约空间和宽带租用的成本
   >- ajax的原则是“按需取数据”，可以最大程度的减少冗余请求和响应对服务器造成的负担，提升站点性能
   >- 基于标准化，广泛被支持
3. 缺点：
    >- 破坏了前进后退功能，用户往往通过后退按钮取消上一步操作，但是ajax无法实现。
    >- ajax的逻辑可以对客户端的安全扫描技术隐藏起来，允许黑客从远程服务器上建立新的攻击，还有自身受到如跨站脚本攻击，SQL注入等攻击
    >- 对搜索引擎支持较弱
```javascript
    let xhr = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject("Microsoft.XMLHTTP");
    xhr.open('url',get,true);
    xhr.send();
    xhr.onreadystatechange = function(){
        if(xhr.status==200&&xhr.readyState==4){
            console.log(xhr.responseText)
        }
    }
    /*
        responseText：响应返回的主体内容，为字符串类型
        responseXML：如果响应类型是"text/xml"或"application/xml"，这个属性中将保存着相应的xml数据，是xml对应的document类型
        status: 响应的HTTP状态码
        statusText：HTTP状态的说明
        readyState：请求/响应过程的当前活动阶段
    */

    /*
        ajax的五个阶段
        0-未初始化，尚未调用open()方法
        1-启动，调用了open()方法，未调用send()方法
        2-发送，已经调用了send()方法，未收到响应
        3-接受，已经接收到部分响应数据
        4-完成，已经接收到全部响应数据
    */
```

17.前端攻击
1. sql注入攻击
>- 就是通过把SQL命令插入到web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL
>- 防范方法:
>- 1. 永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双"-"进行转换等
>- 2. 永远不要使用动态拼装SQL，可以使用参数化的SQL或直接使用存储过程进行数据查询存取
>- 3. 永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接
>- 4. 不要把机密信息明文存放，请加密或hash密码和敏感的信息

2. xss攻击
>- xss(跨站脚本攻击)攻击指的是攻击者往web页面里插入恶意html标签或者javascript代码，比如：攻击者在论讨放一个看似安全的链接骗取用户点击后，窃取cookie中的用户私密信息。或者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点
>- 防范方法:
>- 1. 代码里对用户输入地方和变量都需要仔细检查长度和对">","<",";","'"等字符做过滤；其次任何内容写到页面之前都必须加以`encode`，避免不小心把`html tag`弄出来。这一层做好，至少可以堵住超过一半的xss攻击
>- 2. 避免直接在`cookie`中泄露用户隐私，例如email、密码等
>- 3. 通过`cookie`和系统`ip`绑定来降低`cookie`泄露的危险。这样攻击者得到的`cookie`没有实际价值，不可能拿来重放
>- 4. 尽量采用`post`而非`get`提交表单

3. CSRF攻击
>- CSRF(跨站请求伪造)比起XSS攻击，是另外一种更具危险性的攻击方式，xss是站点用户进行攻击，而CSRF是通过伪装成站点用户进行攻击，而防范的资源也少，难以防范。攻击者盗用用户的身份信息，并以用户名义进行发送恶意的请求等，例如发邮件，盗取账号、转账等非法手段
>- 防范方法：
>- 1. 验证HTTP Referer字段
>- 2. 在请求地址中添加token并验证
>- 3. 在HTTP头中自定义属性验证

4. 网络劫持攻击
5. 钓鱼网站
6. 控制台注入代码

18.webpack的打包过程

19.vuex中的state、mutation、actions
```javascript
/*
    state 保存了组件的数据
    如果要想在组件中使用msg这个数据，最简单的
    直接
        模板中{{$store.state.msg}}
        函数中this.$store.state.msg

        想要好看，则
        computed:{
            msg(){
                return this.$store.state.msg;//其他地方就直接msg就ok
            }
        }
    
    getter 在组件中使用时state方法类似，要把state改成getters
        想要使用reverseMsg
        直接
            模板中{{$store.getters.reverseMsg}}
            函数中this.$store.getters.reverseMsg
        想要好看，则
        computed:{
            reverseMsg:{
                return this.$store.getters.reverseMsg;
            }
        }

    mutation(同步)
        mutation是一个函数，它的作用就是修改state，而且修改state只能通过这一个方式

        我们如果想要组件中对某个数据进行修改，则直接提交对应的mutation即可
        this.$store.commit('setMsg','相关数据');//setMsg是mutation的一个方法

        因为mutation要改变state，所以在mutation中有参数state和载荷payload

    action(异步)
        用法类似与mutation
        一、给mutation传值需要commit
            这是接受的操作
            {
                mutations:{
                    mutation函数(state,payload){
                        //因为mutations改变的是state中的值，所以我们参数中有一个state方便我们快速改变对应的值
                        //payload接受commit处传递过来的数据
                    }
                }
            }
            组件函数中提交mutation，就是给mutation传值
            {
                methods:{
                    函数(){
                        this.$store.commit('mutation函数',数据)
                    }
                }
            }
        二、给action传值需要dispatch
        this.$store.dispatch('action名字',数据)

        因为mutation是同步修改state，所以参数中有state
        但是action是异步获取数据，获取后的数据想要修改到state，因此action中一定要提交mutation去修改state，所以在action的函数中有参数context，这个context就是一个store
        如果想要提交，则context.commit('mutation中的函数名',传的值);
*/
    const store = new Vuex.Store({
        state:{
            msg:'abcdefg'
        },
        getters:{
            reverseMsg(){
                return msg.split('').revese().join('');
            }
        },
        mutations:{
            setMsg(state,payload){
                state.msg = payload
            }
        }
    })

    /*
        在页面中渲染一些数据时，可以把数据放在state中的state
        操作页面元素修改数据时，可以在事件处理函数中this.$store.commit('mutation')，提交mutation 让mutation去修改
        操作页面元素获取新的数据时，可以在事件处理函数中this.$store.dispatch('action')，然后在请求数据成功的时候，让action去commit('mutation')，然后mutations修改数据
        action中代码只涉及到，请求数据 提交mutation
        mutation 只涉及到修改state
        组件中设置到提交mutation或者分发action
    */
```

20.数据去重的方法
```javascript
    //方法一(indexOf直接去重)
    //思路：使用新数组indexOf判断有没有这个元素，没有就添加，最后返回新数组
    function deleteOther(arr) {
      let len = arr.length;
      let brr = [];
      for (let i = 0; i < len; i++) {
        if (brr.indexOf(arr[i]) == -1) {
          brr.push(arr[i])
        }
      }
      return brr;
    }
    let arr = [1, 2, 31, 21, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法二(filter+indexOf索引去重)
    //思路：通过过滤和indexOf，过滤的结果为数据的indexOf和索引相等，不等说明有重复了
    function deleteOther(arr) {
      return Array.prototype.filter.call(arr, (item, index) => {
        return arr.indexOf(item) === index
      })
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法三(相邻去重)
    //思路：先排序，然后相邻比较，不等添加到新数组
    function deleteOther(arr) {
    //   arr.sort(function (a, b) { //也可以这样排序，因为sort会改变数组，返回新数组
    //     return a - b;
    //   })
      var arr = arr.sort(function (a, b) {
        return a - b;
      })
      let brr = [], len = arr.length;
      for (let i = 0; i < len; i++) {
        if (arr[i] !== arr[i - 1]) {
          brr.push(arr[i])
        }
      }
      return brr
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法四(借助对象去重)
    //思路：通过判断对象有没有这个属性，没有则添加并也添加到新数组，最后返回新数组
    function deleteOther(arr) {
      let brr = [], obj = {}, len = arr.length;
      for (let i = 0; i < len; i++) {
        if (!obj[arr[i]]) {
          obj[arr[i]] = 1;
          brr.push(arr[i])
        }
      }
      return brr
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法五(借助es6的Set对象+[...])
    //...内部使用的是for-of
    //思路：Set的一个最大特点就是数据不重复，传入数组可以给数组去重，返回Set对象再转为数组
    function deleteOther(arr) {
      return [...new Set(arr)]
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))

    //方法六(借助es6的Set对象+Array.from())
    //思路：Set的一个最大特点就是数据不重复，传入数组可以给数组去重，返回Set对象再转为数组
    function deleteOther(arr) {
      return Array.from(new Set(arr))
    }
    let arr = [1, 2, 31, 21, 2, 1, 1, 1]
    console.log(deleteOther(arr))
```

21.js数组改变原数组和不改变原数组的方法
1. 改变原数组的方法：
>- push(),pop(),shift(),unshift(),reverse(),sort(),splice()
2. 不改变原数组的方法：
>- concat(),join(),slice(),map(),filter(),forEach(),every(),some(),find(),indexOf(),lastIndexOf,reduce(),reduceRight(),includes(),split(),replace()

22.使用setTimeout实现setInterval
```javascript
// 采用递归的方法
    function mySetInterval() {
        setTimeout(function tick() {
            console.log('tick')
            setTimeout(tick, 1000)
        }, 1000)
     }
```

23.async await
1. async await是generator、promise的语法糖,es7提出的
2. async await必须一起使用
3. async函数返回是Promise对象，这比Generator函数的返回值是Inerator对象方便多了，你可以用then方法指定下一步的操作
4. async函数完成可以看作多个异步操作，包装成的一个Promise对象，而await命令就是内部then命令的语法糖


```javascript
    //使用generator
    function* gen() {
      yield console.log(1)
      yield console.log(2)
      yield console.log(3)
    }
    let ge = gen();
    ge.next();//1
    ge.next();//2
    ge.next();//3

    //promise
    function con(i) {
      return i
    }
    let promise = new Promise(resolve => {
      let data = con(1)
      resolve(data)
    })
    promise.then(res => {
      console.log(res);//1
      return new Promise(resolve => {
        let data = con(2)
        resolve(2)
      })
    }).then(res => {
      console.log(res);//2
      return new Promise(resolve => {
        let data = con(3)
        resolve(3)
      })
    }).then(res => {
      console.log(res);//3
    })

    //async await
    let a = (async () => await 1)()
    let b = (async () => await 2)()
    let c = (async () => await 3)()
    a.then(res => {
      console.log(res)
    })
    b.then(res => {
      console.log(res)
    })
    c.then(res => {
      console.log(res)
    })

```


## 猫眼
### 一面(90分钟)
1.垂直居中的方法
>- 网易有道一面已回答

2.实现三列布局
>- 网易有道一面已回答

3.http缓存
1. 先讲下http报文，http报文是浏览器和服务器间通信时发送及响应的数据块
2. 浏览器向服务器请求数据，发送请求(request)报文，服务器向浏览器返回数据，返回响应(response)报文。
>- 报文信息主要分为两个部分
>- 1.包含属性的首部(header)---附加信息(cookie,缓存信息等)，与缓存相关的规则信息，均包含在header中
>- 2.包含数据的主体部分(body)---HTTP请求真正想要传输的部分
3. http缓存有多种规则，根据是否需要重新向服务器发起请求来分类，将其分为两大类(强制缓存，协商缓存)
4. 强制缓存如果生效，不需要再和服务器发送交互，而协商缓存不管是否生效，都需要与服务器发生交互
5. 两类缓存规则可以同时存在，强制缓存优先级高于协商缓存，也就是说当执行强制缓存的规则时，如果缓存生效直接使用缓存，不再执行协商缓存规则
6. 参考：`https://www.cnblogs.com/chenqf/p/6386163.html`

4.cookie、localstorage、sessionstorage的区别
1. 共同点：保存在浏览器端
2. 区别：
    >- cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而seessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存
    >- cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大的多，可达到5M或者更大
    >- 数据有效期不同，sessionStorage仅在当前浏览器窗口关闭有效，自然也就不可能持久保存，localStorage始终有效，窗口或浏览器关闭也一直保存，因此可做持久数据。cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭
    >- 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面。localStorage、cookie在所有同源窗口中都是共享的
    >- webStorage支持事件通知机制，可以数据更新的通知发送给监听者。
    >- 同源窗口是指打开两个相同的页面a、b，在页面a操作的localStorage也会在页面b生效，localStorage和cookie支持同源窗口，而sessionStorage不支持。

3. cookie一般用于存储什么数据

4. cookie的属性有name：键名，value：键值，domain：主域，path：路径，expires：过期时间，secure：安全标志，httponly：用于限制客户端对cookie的访问，将cookie设置httponly为true可以减轻xss攻击的危害，防止cookie被窃取，以增强cookie的安全性

5. http请求中不带cookie怎么实现
>- axios、jquery设置withCredentials为false，fetch设置credentials为false

6. cookie在头部(header)

5.防抖节流
1. 防抖就是将几次操作合并为一次操作，原理是维护一个计时器，规定在deley时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置，这样一来，只有最后一次函数才会被执行。抖完了再执行，读进度条
>- 使用场景：用户在输入框不断输入，只有最后一次输入才会被执行(百度搜索框)

```javascript
    //防抖
    const debounce = (fn,delay)=>{
      let timer = null;
      return ()=>{
        if(timer!==null){
          clearTimeout(timer);
        }
        timer = setTimeout(()=>{
          fn.apply(this)
        },delay)
      }
    }
    let a = debounce(function(){
      console.log(11)
    },1000)
```

2. 节流就是使得一定时间内只触发一次函数，原理是通过判断是否达到一定时间来触发
>- 使用场景：在页面的无限加载场景下，我们需要用户在滚动时，每隔一段时间内触发一次ajax请求，而不是在用户停下滚动页面操作时才会去请求。这样的场景适合节流技术来实现
```javascript
    //节流
    const throttle = (fn, delay = 500) => {
      let flag = true;
      return () => {
        if (!flag) return 0
        flag = false;
        setTimeout(() => {
          fn.apply(this);
          flag = true;
        }, delay)
      }
    }
    let a = throttle(function () {
      console.log(11)
    }, 1000)
    a()

```

6.微信小程序openid怎么获取
>- 通过wx.login获取res.code，再通过wx.request传入res.code（临时登录凭证）、你小程序的appid、你小程序的secret

7.微信小程序什么方法需要授权才可以调用

8.css3用过什么新特性
1. border-radius-圆角，@font-face字体，box-shadow、text-shadow框和文本阴影
2. word-wrap，background-size，background-origin，border-image，box-sizing，calc，linear-gradient
3. transform转换
    >- 2D转换
    >- 1.rotate旋转，图片转个90°或者180°什么的
    >- 2.translate位置移动
    >- 3.scale，skew，matrix等
    >- 3D转换
    >- 1.rotate(XYZ)根据x，y，z轴旋转
    >- 2.translate(XYZ),scale(XYZ)同理
    >- 3.perspective透视，这个很多3D效果都要设置一下，不然3D还是只有2D的效果
4. transition过渡，简单的动画（如：移个位置，变个长度），直接用这个属性就能搞定
5. animation动画，3D可以调用硬件渲染
6. 新的长度单位：rem、ch、vw、vh、vmax、vmin等
7. clip-path：绘制路径，类似SVG技术
8. flex布局，继table和div后的趋势
9. 伪类选择器，如:target,:enabled,:disabled,:first-child等
10. @media媒体查询，适用于响应式布局中
11. columns：分栏布局
12. will-change：改善渲染性能


9.animation
```css
    div{
        width: 100px;
        height: 100px;
        background: red;
        position: relative;
        animation: mymove 5s infinite;
        -webkit-animation: mymove 5s infinite;
    }
    @keyframes mymove{
        from{left:0px;}
        to{left:200px;}
    }
    @-webkit-keyframes mymove{
        from{left:0px;}
        to{left:200px}
    }
```
```html
    <div></div>
```


10.CDN优化
>- CDN（内容分发网络）的主要工作是把我们需要被分发的内容发到世界各地的各个节点上，让世界各地的人都可以在距离最近，压力最小的网络节点拿到想要拿到的内容，减少网络传输距离从而达到加速的目的（需要提供资源绝对地址告诉CDN厂商，让厂商去智能拉取）
>- CDN能够缓存一般的CSS、js、图片等静态资源文件，而这些文件的访问频率很高，将其缓存在CDN可以极大的提高网站的访问速度
>- 当CDN服务器中缓存有用户请求的数据时，就可以从CDN直接返回给客户端浏览器，最短路径的返回响应，加快用户的访问速度，减少数据中心的负载压力


11.cookie和session的区别，场景
>区别
1. cookie数据放在客户的浏览器（本地），session数据放在服务器上
2. cookie不如session安全，别人可以分析存在本地的cookie并进行cookie欺骗，所以出于安全性的考虑应当使用session
3. session会在一定时间内保存在服务器上。当访问增多，会占用较多的服务器资源，所以处于性能考虑则应当使用cookie
4. 单个cookie保存的数据不能超过4k，很多浏览器都限制一个站点最多保存20个cookie，实际上为了性能考虑，不论是cookie还是session，其中的信息都应当短小精悍
5. session保存在服务器上，所以不支持跨域的访问
6. 每次客户端发送请求，服务端都检查是否含有sessionId。如果有，则根据sessionId检索出session并处理，如果没有，则创建一个session，并绑定一个不重复的sessionId

>场景
1. 一般来说，登录验证信息，客户的私人信息，如姓名、电话等，应该放在session中
2. cookie则用于用户登录网站时的自动登录以及类似购物车的处理，使用cookie保存信息时最好通过加密形式保存数据，用过是否保存登录信息，需要由用户自行选择

12.url输入地址栏后的一系列操作
1. 浏览器先查看浏览器缓存-系统缓存-路由缓存，如果缓存中有，会直接在屏幕中显示页面内容
2. 在发送http请求前，需要域名解析（DNS解析）获取响应的IP地址
3. 拿到IP地址后，浏览器向服务器发起tcp连接，与浏览器建立三次握手
4. 握手成功后，浏览器向服务器发送http请求，请求数据
5. 服务器处理收到的请求，将数据返回给浏览器
6. 浏览器收到http响应
7. 读取页面内容，浏览器渲染，解析html源码
8. 生成DOM树、解析css、js交互
9. 页面重绘、回流
10. 浏览器显示页面内容

13.tcp的三次握手和四次挥手
> 三次握手--TCP连接需要三次握手
1. 第一次握手：建立连接时，客户端发送syn（同步序列编号）包（syn=j）给服务端，并进入SYN_SEND状态，等服务器确认
2. 第二次握手：服务器收到syn包，必须确认客户端的SYN（ack=j+1），同时自己也发送一个syn包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态
3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（k+1），此包发送完毕，客户端和服务端进入建立状态，完成三次握手

> 四次挥手--断开一个TCP连接需要四次挥手
1. 第一次挥手：主动关闭方发送一个FIN（关闭连接），用于关闭主动方到被动方的数据传送，也就是主动关闭方告诉被动方：不会再给你发送数据了（当然，在FIN包之前发送出来的数据，如果没收到对应的ack确认报文，主动方依然会重发这些数据），但是，此时主动方还是接受数据
2. 第二次挥手：被动关闭方收到FIN后，发送一个ACK给对方，确认需要为收到序号+1（与SYN相同，一个FIN占用一个序号）
3. 第三次挥手：被动关闭方发送一个FIN，用于关闭被动关闭方到主动关闭方的数据传送，也就是告诉关闭方，我的数据也发送完了，不会再给你发送数据了
4. 第四次挥手：主动方收到FIN后，发送一个ACK给被动方，确认序号为收到序号+1。至此，完成四次挥手

14.事件冒泡捕获委托
>- 用友一面已回答

15.状态码
>- 200-成功，301-永久重定向，302-临时重定向，304-资源未修改，可在缓存中取，400-请求语法出错，服务器无法理解，403-服务器拒绝，404-页面不存在，405-请求中的方法被禁止，500-服务器报错

16.跨域
>- 美团一面已回答

17.jsonp的回调函数在哪里调用
>- 在后端调用
```javascript
    function test(data){
        console.log(data.name)
    }

```
```javascript
    <script src="http://127.0.0.1:8088/jsonp?callback=test"><script>
```
>- 后端返回
```javascript
    res.end("test({"name":"Monkey"}")
```
>- 以上三段代码等同于
```javascript
    <script>test({"name":"Monkey"})</script>
```

18.sort方法内部实现（好像不同浏览器用的排序方法不一样）
>- sort排序内部有20多种排序的方法
>- 1. Mozilla/FireFox：归并排序
>- 2. V8：数组长度小于等于10采用插入，其他采用快排

19.字符串indexOf方法内部实现
```javascript
    var strStr = function (haystack, needle) {
      if (needle === "") {
        return 0;
      }
      var start = 0;
      var len = needle.length;
      while (start + len <= haystack.length) {
        if (haystack.slice(start, len + start) === needle) {
          return start
        } else {
          start += 1
        }
      }
      return -1
    }
    console.log(strStr('13213213321', '321'))

```

20.vue的双向绑定
>- 在Vue2.x采用数据劫持结合发布者-订阅者模式的方式，通过es5的Object.defineProperty()来劫持各个属性的setter、getter方法，在数据变动时发布信息告诉订阅者，触发相应的监听回调，而Vue3.x则采用es6的Proxy对象来实现，据说该方法可以简约一半的内存，并且他是可以检查到数组内部数据的变化
```javascript
    //简单的双向绑定
    var obj = {}
    Object.defineProperty(obj, 'val', {
      get: function () {
        return obj
      },
      set: function (newValue) {
        document.getElementById('txt').value = newValue;
        document.getElementById('show').innerHTML = newValue;
      }
    })
    document.addEventListener('keyup', function (e) {
      obj.val = e.target.value
    })
```
```html
    <div id ="app">
        <input type="text" id="txt">
        <p id="show"></p>
    </div>
```

21.rem的换算
>- rem是相对根元素<html>，这样就意味着，我们只需要在根元素确认一个参考值，这个参考值设置为多少，完成可以根据自己的需求来定
>- 浏览器默认字号是16px，所以12px=(12/16)rem
>- 根元素font-size如果是10px,那么12px=(12/10)rem
>- 根元素font-size如果是18px,那么12px=(12/18)rem
>- 根元素font-size如果是64x,那么12px=(12/64)rem

22.懒加载
1. 对于图片过多的使用场景，为了提高页面加载速度，改善用户体验，我们对未出现在视野范围的图片先不加载，等到出现视野范围采取加载
2. 这样做能防止一次性向服务器相应大量请求导致服务器响应慢，页面卡顿或崩溃等问题，提高网站的性能
3. 先img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储在img标签的自定义属性中（比如data-img）
4. 当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果
```html
    <li class="item">
        <a href="javascript:void(0)">
            <img data-img="${p.pic}" src="img/black.jpg"/>
        </a>
    </li>
    <!--参考 https://blog.csdn.net/weixin_38840741/article/details/80117553 -->
```


23.事件监听
>- addEventlistener，第一个传事件，第二个传函数，第三个传false(冒泡)/true(捕获)，默认false(冒泡))(事件没on)
>- ie的是attachEvent(事件有on)

24.箭头函数和普通函数的区别
1. 箭头函数语法更加简单、清晰
2. 箭头函数不会创建自己的this，默认是函数定义位置的上下文this，普通函数的this是window
3. 箭头函数的this无法通过call、apply、bind改变，普通函数可以
4. 箭头函数不能做构造函数使用
5. 箭头函数没有arguments
6. 箭头函数没有原型prototype
7. 箭头函数不能用作Generator，不能使用yeild关键字

```javascript
    function fn() {
      console.log(this);
      return () => {
        console.log(this)
      }
    }
    let obj = {
      name: 'aa'
    }
    let result1 = fn();//window
    result1();//window
    let result = fn.call(obj);//obj
    result();//obj

    var age = 100;
    let obj = {
      age:20,
      say:()=>{
        console.log(this.age)
      },
      say1:function(){
        console.log(this.age)
      }
    }
    obj.say();//100
    obj.say1();//20


```

25.this指针

26.事件监听(on)和触发(trigger)


27.找出数组中两个和为某数的索引
>- leetcode第一题
```javascript
    //思路：通过map函数的if-in方法，存储之前的值，然后判断里面有没有
    var twoSum = function (nums, target) {
      let map = {};
      let len = nums.length;
      for (let i = 0; i < len; i++) {
        let targetNum = target - nums[i];
        if (targetNum in map) return [map[targetNum], i]
        map[nums[i]] = i
      }
    };
    console.log(twoSum([3, 2, 4], 7))
```



## 涂鸦游戏
### 一面(30分钟)
1.说一个你最熟悉的项目

2.两个栈如何实现一个队列
>- 栈：先进后出，队列：先进先出
>- 思想：将数据先全部入栈到栈a。然后将栈a的数据依次出栈到栈b，最后栈b依次出栈即可
>- 这个复杂度比较高，可以想想有没有其他方法
```javascript
    var stack1 = [];
    var stack2;
    //入栈
    function push(node){
        stack1.push(node)
    }
    //出栈
    function pop(){
        stack2 = stack1.shift();
        return stack2
    }

```

3.快排
>- 比较的时候不用新的数组，操作当前数组的元素做交换，怎么实现
```javascript
    //以前是这样做的，需要添加多两个数组来存储
    function quickSort(arr) {
      if (arr.length <= 1) {
        return arr
      }
      let left = [], right = [];
      let curNum = Math.floor(arr.length / 2);
      let curTemp = arr.splice(curNum, 1);
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] > curTemp) {
          right.push(arr[i])
        } else {
          left.push(arr[i])
        }
      }
      return quickSort(left).concat(curTemp, quickSort(right))
    }

    //这个时间复杂度比较高
    //现在是这样做的，直接操作该数据
    //找一个基准(第一个数)，然后左右两边同时开始，左边比准基大，停止，当右边对基准小，停止，两者交换。分别去找不属于自己这一边的，最后判断基准已当前left的值，大着交换
    function quickSort(arr) {
      let len = arr.length;
      if (len <= 1) {
        return arr
      }
      let left = 0, right = len - 1;
      let temp = arr[0];
      while (left < right) {
        while (left < right && arr[left] <= temp) {
          left++
        }
        while (left < right && arr[right] >= temp) {
          right--
        }
        [arr[left], arr[right]] = [arr[right], arr[left]]
      }
      if (temp > arr[left]) {
        [arr[0], arr[left]] = [arr[left], arr[0]]
      }
      return quickSort(arr.slice(0, left)).concat(quickSort(arr.slice(left)))
    }
```

4.二叉树的层次遍历
>- 一层一层的遍历输出
```javascript
    function PrintFromTopToBottom(root){
        var arr = [];//输出结果数组
        var queue = [];//保存各个节点
        var head;//当前节点
        if(root!=null){//判断root有没有节点
            queue.push(root);//将根节点先入栈
        }
        while(queue.length!=0){//各节点遍历
            head = queue.shift();//取出当前第一个节点
            arr.push(head.val)//将节点值入值
            if(head.left){//判断是否有左节点，有入栈到queue
                queue.push(head.left)
            }
            if(head.right){//判断是否有右节点，有入栈到queue
                queue.push(head.right)
            }
            //左节点在前面，右节点在后，子节点进入队列，先进先出
        }
        return arr
    }
```

5.如何解决一直创建销毁对象的问题

6.数据库的连接池怎么工作

7.反链表
  
## 小米
### 一面(65分钟)
1.let、const、var的区别
1. var声明的变量会挂载到window上，而let和const声明的变量不会
2. var声明的变量会被提升，let和cosnt不会
3. let和const声明形成块级作用域，而var不存在此作用域
4. 同一作用域下let和const不能声明同名变量，而var可以
5. let、const存在暂存死区
6. const声明的变量必须初始化，不能使用null占位，声明后不能再修改，如果是复合类型数据，可以修改其属性
7. 参考：https://blog.csdn.net/aaa333qwe/article/details/90665074

2.同源策略
>- 同源策略就是协议、域名、端口都相同，则这两个页面具有相同的源

3.TCP、UDP、IP、HTTP在哪一层
>- 应用层(第七层))、表示层、会话层、传输层、网络层、数据链路层、物理层(第一层)
>- TCP、UDP在传输层(第四层)
>- IP在网络层(第三层)
>- HTTP在应用层(第七层)

4.如果catch返回了一个数据，后面的then还会执行吗？
>- 会执行

5.transition和animation的区别
1. 两者都可以做动画效果的css3属性
2. transition是做过渡动画，比如鼠标经过的时候才会作用。没有中间的过程，动画一步到位，鼠标经过只可以发生一次，不能重复发生动画
3. animation的动画是一帧一帧的绘制的，可以绘制复杂动画，需要配合@keyframes来使用

6.relative、absolute、fixed相对什么定位
>- relative相对自己，其在普通流中的位置进行定位
>- absolute相对最近的一级
>- fixed相对浏览器窗口会随着浏览器滚动而滚动
>- static默认值没有定位，元素出现在正常的流中

7.http的头部
1. http请求头部有Cookie、Contection、Content-Type、Date、If-Modified-Since、If-None-Match
2. http响应头部有Set-Cookie、Cache-Control、Content-Language、Content-Length、Date、Content-Type、ETag、Last-Modified、Expires

8.vue的声明周期钩子及各个阶段做了什么
>- beforeCreated---组件实例化之前
>- created---组件实例化完毕，单页面还没显示
>- beforeMount---组件挂载前，页面仍未展示，但虚拟dom已经配置，{{}}
>- mounted---组件挂载后，此方法执行后，页面显示
>- beforeUpdate---组件更新前，页面仍未更新，但虚拟dom已经配置
>- updated---组件更新，此方法执行后，页面显示
>- beforeDestroy---组件销毁前
>- destroyed---组件销毁

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>vue的实例生命周期</title>
  <script src="https://cdn.bootcss.com/vue/2.5.17-beta.0/vue.js"></script>
</head>
<body>
  <div id="app">
    <p ref="k">{{number}}</p>
  </div>
  <script>
    let vm = new Vue({
      el: '#app',
      data: {
        number: 123
      },
      beforeCreate: function () {
        console.log('%cbeforeCreate 钩子执行...', 'color: red; font-size: 20px;');
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.number); // 拿不到的
        console.log(this.$refs.k);
      },
      created: function () {
        console.log('%ccteated 钩子执行...', 'color: red; font-size: 20px;');
        console.log(this.number)
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.$refs.k);

        // ajax 请求
        // 直接操作dom节点
        this.$nextTick(()=>{
          console.log('nextTick')
          console.log(this.$refs.k);
        });
      },
      beforeMount: function () {
        console.log('%cbeforeMount 钩子执行...','color: red; font-size: 20px;');
        console.log(this.number)
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.$refs.k);
      },
      mounted: function () {
        console.log('%cmounted 钩子执行...','color: red; font-size: 20px;');
        console.log(this.number)
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.$refs.k);
      },
      beforeUpdate: function () {
        console.log('%cbeforeUpdate 钩子执行...','color: red; font-size: 20px;');
        console.log(this.number)
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.$refs.k);

      },
      updated: function () {
        console.log('%cupdated 钩子执行...','color: red; font-size: 20px;');
        console.log(this.number)
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.$refs.k);

      },
      beforeDestroy: function () {
        console.log('%cbeforeDestroy 钩子执行...','color: red; font-size: 20px;');
        console.log(this.number)
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.$refs.k);

      },
      destroyed: function () {
        console.log('%cdestroyed 钩子执行...','color: red; font-size: 20px;');
        console.log(this.number)
        console.log('%cthis.$el %o :', 'color:green;',this.$el);
        console.log(this.$refs.k);
      }
    });
  </script>
</body>
</html>
```

```javascript
    //1. new Vue({}) 表示：实例初始化，创建新的new实例
    //2. Init Events & Lifecycle初始化所有的监听事件+生命周期钩子，初始化所有的数据观测和加载响应的事件。
    //3. beforeCreate在实例初始化之后，数据观测（data observer）和event/watcher事件配置将会调用
    //4. Init injections & reactivity初始化依赖注入和相关响应，数据观测（data observer）和event/watcher事件配置将会调用
    //5. created在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测（data observer），属性和方法的运算，watch/event事件回调，挂载阶段还没开始，$el属性目前不可见。
    //6. Has ‘el’ option？询问是否有挂载的根标签
    //7. Yes => Has 'template' option？询问是否有template模板，是否有组件的渲染
    //8. No => When app.$mount(el) is called? 生命周期检测到在当前，你没有el，就询问你这个组件是否已经进行了有效的挂载==>返回7
    //9. Yes=> compile template into render function
    //如果template模板存在，按照编译模式依赖注入
    //10. NO=>compile el's outerHTML as template
    // 如果不存在template模板，就可以将当前元素内的outerHTML作为渲染标签template模板来展示
    //11. beforeMount在挂载开始之前被调用：相关的render函数首次被调用
    //12. mounted el被新创建的vm.$el替换，并挂载到实力上去之后调用该钩子，如果root实例挂载了一个文档内元素，当mounted被调用时vm.$el也在文档内
    //13. beforeUpdate数据更新时调用，发生在虚拟dom打补丁之前
    //14. Virtual DOM re-render & patch
    //虚拟dom的重渲染+打补丁（删除数组中的某一项或者添加修改某一项&dom节点的删除和渲染）
    //15. updated由于数据更改导致的虚拟dom重新渲染和打补丁，在这之后会调用该钩子
    //16. beforeDestroy()实例销毁之前调用。在这一步，实例仍然完全可用
    //17. Teardown watchers and child component and event listener
    //卸下所有的监听者，函数，所有的子组件
    //19.destroyed() Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解绑定，所有的事件监听会被移除，所有的子实例也会被销毁
```

9.vue的v-if和v-show
>- v-if是“真正”的条件渲染，因为他会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建
>- v-if也是惰性的，如果在初始渲染的条件为假，则什么也不会做一直到第一次变为真时，才会开始渲染条件快
>- 相比之下，v-show简单的多，不管初始条件是什么，元素总是会被渲染，并且只是简单得基于css进行切换
>- 一般来说，v-if有更好得切换开销，而v-show有更高得初始渲染开销。因此，如果需要非常频繁地切换，则使用v-show较好，如果在运行时条件很少改变，则使用v-if较好

10.vue路由的hash和history的区别
>- 前端路由的核心在于--改变视图的同时不会向后端发出请求
1. hash--即地址栏URL中得#符号（此hash不是密码学里得散列运算）。比如这个URL：`http://www.baidu.com/#/aaa`，hash的值#/aaa。它的特点在于：hash虽然出现在URL中，但不会被包括在HTTP请求中，对后端完全没有影响，因此改变hash不会重新加载页面。此处我们在任何网址后面输入#abc刷新，页面都不会跳转得，history则相反，没有对应得页面就是出现404
2. history--利用了HTML5新增的pushState()和replaceState()方法。（需要特定浏览器支持），这两个方法应用于浏览器的历史记录栈，在当前back、forward、go的基础之上，它们提供了对历史记录进行修改的功能，只是当它们执行修改时，虽然改变了当前的URL，但浏览器不会立即向后端发送请求
3. 因此可以说，hash模式和history模式都属于浏览器自身的特性，Vue-Router只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由


11.vue的keep-alive
1. keep-alive是Vue的内置组件，能在组件切换过程中将状态保留在内存中，防止重复渲染DOM
2. keep-alive包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们
3. keep-alive与transition相似，是一个抽象组件，它不会在DOM树中渲染（真实或者虚拟都不会），也不在父组件链中存在，比如：你永远在this.$parent中找不到keep-alive

12.vue的组件通信
1. 父向子通过props
2. 子向父通过$emit(子),$on(父)
3. 兄弟组件通过bus
4. 子组件写ref，然后通过$refs调用子组件的方法属性
5. 没关系的组件vuex

>- 通过props是单向绑定的
>- 1. 每次父组件更新时，子组件的所有prop都会更新为最新值
>- 2. 不要在子组件内部改变prop，如果你这样做了，Vue会在控制台给出警告
>- 3. 如果需要改变，则将prop赋值给子组件的data，这样也有问题，需要注意传入的类型是引用类型还是基本类型，只有基本类型才能直接赋值，这涉及到深拷贝
>- 4. 我们可以通过$parent来直接修改父组件的数据，不会报错

13.vue的v-for的key值作用，用id和index的区别
1. key的作用是让vue更加高效的渲染虚拟dom
2. 如果使用index作为key值，当我们对v-for循环的组数添加了新的数据，那么index就会发生变化
3. 而使用id作为key值，如果原本有3个`<li>`，那么diff算法发现原本三个`<li>`的key值没有改变，只是循环新添加了一些数据，那么原本的3个`<li>`就可以复用也就是利用了虚拟dom在性能上的优势

14.vue的vuex
>- 网易有道一面已回答

15.css行内元素和块级元素区别
1. 块级元素
>- `<div>、<ul>、<ol>、<li>、<h1>--<h6>、<header>、<main>、<footer>、<p>`
>- 总是独占一行，宽高、内外边距都是可以控制的

2. 行内元素
>- `<a>、<b>、<button>、<em>、<i>、<img>、<input>、<label>、<strong>`
>- 在一行之内，跟行内元素在同一行
>- 不能用width属性，比如对行内元素span用width:200px，是看不到效果的
>- 不能用height属性，高度可以通过line-height来指定
>- 行内元素能够给它设置padding，但仅仅有padding-left和padding-right有效，没有padding-top和padding-bottom。margin属性也是和padding属性一样。对行内元素左右有效，上下无效

3. 可以通过display改变，display:block、display:inline-block、display:inline

16.BFC
1. BFC(Block Formatting Context)全称是块格式化上下文
2. 触发BFC的方法
>- 浮动元素：float除none以外的值
>- 绝对定位元素：position(absolute、fixed)
>- display为inline-block、table-cell、flex
>- overflow除了visible以外的值(hidden、auto、scroll)
3. 可以通过overflow:hidden解决margin重合问题，用一个div包含他们再设置其属性即可
4. 可以通过overflow:hidden解决浮动导致父元素高度崩溃，给父元素设置其属性即可
参考：https://blog.csdn.net/qiphon3650/article/details/79427334

17.两列布局，左边固定，右边自适应
1. 通过父元素display:flex，子左边：width:200px，右边：flex:1
```css
    .wrapper{
      display: flex;
    }
    .left {
      width: 200px;
      background: red;
    }

    .right {
      flex: 1;
      background: green;
    }
```
2. 浮动
```css
    .left {
      width: 30%;
      background: red;
      float: left;
    }

    .right {
      /* flex: 1; */
      float: right;
      width: 70%;
      background: green;
    }
```
3.定位
```css
    .wrapper {
      position: relative;
      height: 500px;
      border: 1px solid #000;
    }

    .left {
      background: #fcc;
      width: 200px;
      position: absolute;
    }

    .right {
      background: #f66;
      position: absolute;
      left: 200px;
      right: 0;
    }

```

18.rem
>- 美团一面已回答

19.继承
>- 用友一面已回答

20.作用域链
>- B站一面已回答

21.说结果
```javascript
    if (true) {
      var a = 1
      console.log(a);//1
    }
    console.log(a);//1
    //////////////////////////////////////

    if (true) {
      let a = 1
      console.log(a);//1
    }
    console.log(a);//a is not defined

```

21.说一个实习，你做的一件不错的事情

22.js实现一个new方法
```javascript
    function _new(fn) {
      return function () {
        let obj = {
          __proto__: fn.prototype
        }
        fn.apply(obj, arguments)
        return obj
      }
    }
    function person(name, age) {
      this.name = name;
      this.age = age;
    }
    person.prototype.sayHi = function () {
      console.log(this.name)
    }
    let obj = _new(person)('小米', 14);
    obj.sayHi();//小米
    console.log(obj);
    // person {name: "小米", age: 14}
    // age: 14
    // name: "小米"
    // __proto__:
    // sayHi: ƒ ()
    // constructor: ƒ person(name, age)
    // __proto__: Object

```

23.判断一个二叉树是不是镜像二叉树，尽量不要使用递归
```javascript
    function fn(tree) {
      if (tree == null) {
        return
      }
      return fn1(tree.left, tree.right)
    }
    function fn1(treeLeft, treeRight) {
       if (treeLeft == null && treeRight == null) {
        return true
      }
      if (treeLeft == null || treeRight == null) {
        return false
      }
      if (treeLeft.val != treeRight.val) {
        return false
      }
      return fn1(treeLeft.right, treeRight.left) && fn1(treeLeft.left, treeRight.right)
    }
```

24.求两个数的最大公约数和最小公倍数
```javascript
    function fn(a, b) {
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      let minBei = 0, maxYue = 0;

      //最大公约数
      for (let i = min; i > 0; i--) {
        if (a % i == 0 && b % i == 0) {
          maxYue = i;
          break;
        }
      }
      //最小公倍数
      for (let i = max; i < a * b; i++) {
        if (i % a == 0 && i % b == 0) {
          minBei = i;
          break;
        }
      }
      return [maxYue, minBei]
    }
```


## 深信服
### 一面(60分钟)
1.数组扁平化
```javascript
    //方法1--js的api调用
    function fn(arr) {
      let arr1 = arr.join(',').split(',');
      let arr2 = arr1.map(item => parseInt(item));
      console.log(arr2)
    }
    console.log(fn([1, [2, 3, [4, 5]]]))

    //方法2--递归
    function fn(arr) {
      let result = [];
      for (let i = 0; i < arr.length; i++) {
        if (Array.isArray(arr[i])) {
          result = result.concat(fn(arr[i]))
        } else {
          result.push(arr[i])
        }
      }
      return result
    }
```
2.数组去重
>- 网易有道已回答

3.最大公共因子字符串

4.全排序
```javascript
    function permute(nums) {
      var res = [];
      if (nums.length > 1) {
        let left = nums[0];
        let reset = nums.slice(1);
        let newRes = permute(reset);
        for (let i = 0; i < newRes.length; i++) {
          for (let j = 0; j < newRes[i].length + 1; j++) {
            let temp = newRes[i].slice(0, j).concat(left, newRes[i].slice(j));
            res.push(temp)
          }
        }
      } else {
        return [nums]
      }
      return res
    }
    

```
5.如何组件封装
1. 举的例子是搜索框的封装
>- 将展示内容data传到搜索框组件，根据input输入返回新的搜索内容searchDate，展示内容区显示的为searchDate

2. 内聚性
>- 块内联系，模块的功能强度和度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高
>- 高内聚是指一个软件模块是由相关性很强的代码组成，只负责一项任务，也就是常说的单一责任原则

3. 耦合性
>- 块间联系，指软件系统结构中各模块间相互联系紧密程度的一种度量。模块之间联系越紧密，其耦合性就越强，模块的独立性则越差。模块间耦合高低取决于模块间接口的复杂度、调用的方式及传递的信息
>- 对于低耦合，粗浅的理解是：一个完整的系统，模块与模块之间，尽可能的使其独立存在。也就是说，让每个模块，尽可能的独立完成某个特定的子功能，模块与模块之间的接口，尽量的少而简单。如果某两个模块间的关系比较负责的话，最好首先考虑进一步的模块划分。这样有利于修改和组合


6.数组过滤
```javascript
var permute = function (nums, what) {
   let result = [];
   for (let val of nums) {
     let obj = {}
     if (val.name == what) {
       obj['name'] = val.name
     }
     if (val.children) {
       if (JSON.stringify(permute(val.children, what)[0]) != '{}') {
         obj['children'] = permute(val.children, what)
       }
     }
     result.push(obj)
   }
   return result
 }
 let arr = [
   {
     name: 'b',
     children: [
       {
         name: 'a',
         children: [
           {
             name: 'b',
             children: [{
               name: 'b'
             }]
           }]
       }]
   },
   {
     name: 'a',
     children: [
       {
         name: 'b',
         children: [
           {
             name: 'b',
             children: [{
               name: 'a'
             }]
           }]
       }]
   }
 ]
 console.log(permute(arr, 'b'))
```

7.为什么要节流
>- 为了限制函数的执行频率，用于优化函数触发频率过高而导致响应速度跟不上触发频率而出现bug、延迟、卡顿等现象
>- 比如window对象的resize、scroll事件、拖拽时的mousemove事件、射击游戏中的mousedown、keydown事件

8.webpack的打包过程


## thoughtworks
### 一面(300分钟)
1.群面无领导小组讨论

2.无人机拍摄

## fordeal
### hr面(15分钟)
1.自我介绍

2.介绍项目

3.实习做的事情

4.期望薪资

5.会选择留在实习公司吗？为什么？

6.有什么想问的


## 米哈游
### 一面(55分钟)
问题都很常规

1.自我介绍

2.项目(深问)

3.你知道的数据结构

4.冒泡排序怎么写，时间复杂度

5.快速排序怎么写，时间复杂度

6.let、const、var

7.原型和原型链

8.事件流，使用场景有什么

9.vue生命周期，各个阶段做了什么

10.promise

11.解构赋值，使用场景

12.vue的computed

13.垂直水平居中的方法

14.em和rem的区别+一道题目

15.同源策略

16.跨域

17.闭包

18.事件循环机制

19.vue的computed属性

20.webpack配置，用过哪些

21.es6的Set对象有什么用

22.浏览器存储

23.vue组件通信方法

24.组件如何封装

25.vue的vuex

26.箭头如何实现

27.精灵图sprite


### 二面(35分钟)
1.如何判断一个链表是循环链表，有几种方法
>- 循环链表是另一种形式的链式存贮结构。它的特点是表中最后一个结点的指针域指向头结点，整个链表形成一个环。如果去遍历循环链表，则是死循环。
>- 这里判断循环链表的方法是：用两个指针，一个指针是快指针(跳一个节点遍历)，遍历快(p=p.next.next)。一个指针逐步遍历，慢指针。
>- 如果在遍历当中，发生这两个指针有出现NULL指针的话，那么它就是单链表。如果是循环链表中，慢指针一定可能和快指针重叠(类型运动员超跑一样)
```c++
int IsCircularList(pNode* pHead)
{
    pnode* pFastNode,pSlowNode;
    pFastNode = pHead;
    pSlowNode= pHead;
    while(1) {
 	    if(pSlowNode == NULL || pFastNode == NULL) {
        printf("This is list\n");
        return 1
      }
	  pSlowNode = pSlowNode->next;
	  pFastNode = pFastNode->next->next;
	  if (pSlowNode == pFastNode || pFastNode->next == pSlowNode) {//快指针和慢指针重合或者快指针的下一个节点和慢指针重合
	   	printf("The si IsCircularList\n");
	    return 0;
	  }
    return 0;
}
```

2.为什么要双指针，单指针为什么不行
>- 如果已知链表的长度可以使用单指针，当经过n步后，如果为null那么就不是循环链表

3.快排最快为什么是nlogn，最坏为什么是n2，什么情况下
>- 在无序的条件最好：nlogn
>- 在有序的条件最坏：n2

4.排序稳定性和不稳定性是什么意思
>- 假定在待排序的记录序列中，存在多个相同的关键字的记录，若经过排序，这些记录的相对次序保持一致，即在原序列中，a=b，且a在b之前，而排序后的序列中，a仍在b之前，则这种算法是稳定的；否则成为不稳定的

5.推排序
>- 每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，用于升序排列
>- 每个节点的值都小于或等于其左右孩子节点的值，成为小顶堆，用于降序排列
>- 堆排序的平均时间复杂度是O(nlogn)
>- 参考：https://blog.csdn.net/u010452388/article/details/81283998

6.TCP的三次握手
>- 猫眼一面已回答

7.TCP和UDP有什么区别，各自的场景有什么
1. TCP和UDP都是传输层协议，TCP提供可靠的通信传输；UDP常用于广播提供无连接的通信服务
2. TCP面向连接（如打电话要拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接
3. TCP提供可靠的服务，通过TCP传输的数据是无差错，不丢失，不重复且有序到达；UDP是尽最大的努力交付，即不保证交付的可靠性
4. 每一条TCP连接都只能点到点；UDP则支持一对一，一对多，多对一，多对多的交互通信
5. TCP一般用于文件传输（FTP HTTP对数据准确性要求高，速度可以相对慢点），发送或者接受邮件（POP IMAP SMTP对数据准确性要求高，非紧急应用），远程登录（TELENT SHH对数据准确性有一定要求，有连接的概念）等等
6. UDP一般用于即时聊天（QQ聊天对数据准确性和丢包要求比较低，但速度必须快），在线视频（RTSP速度一定要快，保持视频连续，但偶尔模糊一个图像帧，人们还是能接受的），网络语音电话（VoIP语音数据包一般比较小，需要高速发送，偶尔断音或者串音也是没有问题的）

8.微信视频聊天用的是什么协议
>- UDP和HTTP

9.TCP报文格式
>- 源端口、目的端口、序号、确认号、首部长度、保留、控制位
(URG(紧急1位)、ACK(确认号)、PSH(推送)、RST(复位)、SYN(同步)、FIN(终止))、窗口、校验和、紧急指针、选项
>- 参考：https://www.cnblogs.com/feng9exe/p/8058891.html

10.UCP报文格式
>- 分为首部字段和数据字段，其中首部字段只占用8个字节，分别是各自占用两个字符的源端口、目的端口、长度、校验和

11.http的缓存机制，强缓存和协商缓存
>- 猫眼一面已回答

12.Etag(Entity Tag-实体标签))是怎么判断的
>- 实现过程
```html
<!--请求端代码-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Cache-Control & ETag</title>
    <link rel="stylesheet" href="css/default.css?version=1"> <!--比较大的文件，用来测试Cache-Control -->
  </head>
  <body>
    <script src="js/main.js"></script> <!--比较大的文件，用来测试ETag-->
  </body>
</html>
```
```javascript
//服务端代码
if (pathName === '/js/main.js'){
    //使用ETag
    let string = fs.readFileSync('./js/main.js', 'utf8')
    response.setHeader('Content-Type', 'application/javascript; charset=utf8')
    let fileMd5 = md5(string)
    response.setHeader('ETag', fileMd5)
    response.write(string)
    response.end()
}
```
>- 此时客户端每次请求这个资源(main.js),都会带上if-none-match这个key，这个key的value就是在服务端通过MD5处理后的MD5值
>- 服务端读取if-none-match的内容，和本次MD5处理后的内容做协商，如果一样，那么就返回304，不返回请求内容。如果不一样，就是资源有更新变动，就将其返回，并且写入新的MD5处理后的ETag
```javascript
if (pathName === '/js/main.js'){
    //使用ETag
    let string = fs.readFileSync('./js/main.js', 'utf8')
    response.setHeader('Content-Type', 'application/javascript; charset=utf8')
    let fileMd5 = md5(string);//文件改变了，那么生成的MD5也会不一样
    response.setHeader('ETag', fileMd5)
    if(request.headers['if-none-match'] === fileMd5){
      //main.js没有更新，没有响应体
      response.statusCode = 304
    } else{
      //有更新，再把新的内容返回
      response.write(string)
    }
    response.end()
}

```

13.如何做强缓存，如果我要现在要强缓存一个5分钟的数据，有什么方法
>- 设置Cache-Control的max-age为300(response.setHeader('Cache-Control','max-age=300'));秒作为单位

14.为什么既有Last-Modified还有Etag
>- HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题
1. 一些文件也许会周期性的更改，但是他的内容并不改变(只是时间发生修改)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改(比如说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)
3. 某些服务器不能精确的得到文件的最后修改时间
>- 这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务端的唯一标识符。Last-Modified与Etag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才确定是否返回304

15.做动画的方法有什么
1. JavaScript直接实现
2. SVG(可伸缩矢量图形)
3. CSS3 transition
4. CSS3 animation
5. Canvas动画
6. requestAnimationFrame
>- 参考：https://www.cnblogs.com/zhaowy/p/8817944.html

16.transition和animation有什么区别
>- transition是过渡属性，强调过渡，它的实现需要触发一个事件(比如鼠标移动上去，焦点，点击等)才能执行动画，它类似于flash的补间动画，设置一个开始关键帧和一个结束关键帧。
>- animation是动画属性，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环执行。可以配合@keyframe定义多个关键帧完成动画

17.js的事件循环机制，场景有什么
>- B站一面已回答

18.vue的虚拟dom，说一下diff算法是怎么实现的

19.下面例子在内存中怎么存储
```javascript
  var obj = {
    a:1,
    b:true,
    c:[],
    d:{}
  }
```

20.SVG和Canvas的区别
>- 两者都允许你在浏览器上创建图形，但是它们根本上是不同的。
1. Canvas
>- 通过JS来绘制2D图形
>- 是逐像素进行渲染的
>- 其位置发生改变，会重新进行绘制
>- 依赖分辨率
>- 不支持事件处理器
>- 弱的文本渲染能力
>- 能够以.png或.jpg格式保存结果图像
>- 最适合图形密集的游戏，其中的许多对象会被频繁重绘
>- 参考:https://www.runoob.com/w3cnote/html5-canvas-intro.html

2. SVG
>- 一种使用XML描述2D图形的语言
>- SVG基于XML意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加JS事件处理器
>- 在SVG中，每个被绘制的图形被视为对象，如果SVG对象属性发生改变，那么浏览器能够自动重现图形
>- 不依赖分辨率
>- 支持事件处理器
>- 最适合带有大型渲染区域的应用程序(比如谷歌地图)
>- 复杂度高会减慢渲染速度(任何过度使用dom的应用都不快)
>- 不适合游戏应用
>- 参考：https://www.w3school.com.cn/svg/index.asp


21.实习对你个人有什么帮助

## 国双科技
### 一面
1.聊天

2.vue的computed和watch原理实现有什么区别

3.vue如何监听路由的变化
```javascript
  watch:{
    $route(to,from,next){
      //to:Route：即将要进入的目标 路由对象
      //from:Route：当前导航正要离开的路由

      //next:Function：一定要调用该方法来resolve这个钩子。执行效果依赖next方法的调用参数
      //next()：进行管道中的下一个钩子，如果全部钩子执行完了，则导航的状态就是comfirmed（确认的）。
      //next(false)：中断当前的导航。如果浏览器的URL改变了（可能是用户手动或者浏览器后退按钮），那么URL地址会重置到from路由对应的地址
      //next('/')或者next({path:'/'})：跳转到一个不同的地址。当前的导航被中断，然后进行一个新的导航。你可以向next传递任意位置对象，切允许设置诸如replace:true、name:'home'之类的选项以及任何用在router-link的to prop或router.push中的选项
      //next(error)：(2.4.0+)如果传入next的参数是一个Error实例，则导航会被终止且该错误会被传递到router.onError()注册过的回调
      console.log(to,from);    
      }
  }
```

4.vue的render
>- 在vue中我们使用模板HTML语法组建页面，使用render函数我们可以用js语言来构建dom
>- 因为vue是虚拟dom，所以在拿到template模板时也要转译成VNode的函数，而用render函数构建DOM，vue就免去了转译的过程
>- 当使用render函数描述虚拟dom时，vue提供一个函数，这个函数就是构建虚拟dom所需要的工具。官网给他起名createElement，简写h
>- createElement方法，通过render函数的参数传递进来，有三个参数：
>- 1.第一个参数（必要参数）：主要用于提供DOM的html内容，类型可以是字符串、对象或函数
>- 2.第二个参数（类型是对象，可选）：用于设置这个DOM的一些样式、属性、传的组件的参数、绑定事件之类的
>- 3.第三个参数（类型是数组，数组元素类型是VNode，可选）：主要是该结点下还有其他结点，用于设置分发的内容，包括新增的其他组件。注意，组件树中的所有VNode必须是唯一的
>- 参数：https://blog.csdn.net/fly_distance/article/details/86632852

5.vue的指令有哪些
>- v-class
>- v-bind
>- v-on
>- v-for
>- v-if
>- v-else
>- v-else-if
>- v-show
>- v-html
>- v-once
>- v-model
>- v-slot
>- v-text
>- 参考：https://www.jianshu.com/p/c4a87e1b4ef7

6.vue的指令和组件有什么区别

7.vue如何自定义指令
>- 全局：Vue.directive
>- 局部：directives:{}
>- 自定义指令的钩子函数
>- 1.bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置
>- 2.inserted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）
>- 3.update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新
>- 4.componentUpdated：指令所在组件的VNode及其子VNode全部更新后调用
>- 5.unbind：只调用一次，指令与元素解绑时调用
>- 钩子函数参数
>- 1.el：指令所绑定的元素，可以用来直接操作DOM
>- 2.binding：一个对象包含以下属性
>- >- name：指令名，不包括v-前缀
>- >- value：指令的绑定值，例如：v-my-directive="1+1"中，绑定值为2
>- >- oldValue：指令绑定的前一个值，仅在update和componentUpdated钩子中可用。无论值是否改变都可用
>- >- expression：字符串形式的指令表达式。例如v-my-mydirective="1+1"，表达式为"1+1"
>- >- arg：传给指令的参数，可选。例如v-my-directive:foo中，参数为"foo"
>- >- modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar中，修饰符对象为{foo:true,bar:true}
>- 3.vnode：Vue编译生成的虚拟节点
>- 4.oldVnode：上一个虚拟节点，仅在update和componentUpdated钩子中可用
>- 参考：https://cn.vuejs.org/v2/guide/custom-directive.html
>- 参考：https://jackchengd.github.io/2019/11/29/vue-directives/#more

8.js的发布订阅

9.事件的循环机制

10.事件流的过程
>- 捕获、处理、冒泡
>- 参考：https://www.cnblogs.com/sunyan-blog/p/11869040.html

11.如何绑定捕获、处理、冒泡事件

12.使用箭头函数需要注意什么
1. 没有自己的this值，箭头函数的this指向在定义的时候继承自外层第一个普通函数的this。如果箭头函数外层没有普通函数，它的this会指向window(全局对象)
2. 要实现类似纯函数的效果，必须剔除外部状态。所以箭头函数不具备普通函数里最常见的this、arguments等，当然也就不能用call()、apply()、bind()去改变this的指向
3. 对于箭头函数来说，并没有自己的this，它的this将始终指向让它生效的对象，即它的外部调用者
4. 参考：https://www.cnblogs.com/mmy67/p/9805215.html

13.数据类型有哪些

14.如何判断是不是数组

15.数组和Symbol有什么区别

16.for-of可以遍历什么类型的数据

17.什么类型可以使用迭代器

18.数组如何去重

19.cookie的作用

20.inline和inline-block有什么区别

21.防抖节流以及各自的使用场景

22.inline-box是什么

23.line-height有什么用
1. 又称行高，指的是两行文字基线之间的距离，又可以称为这行文字所占的高度
2. 参考：https://juejin.im/post/5bf805fde51d453a68008e32

24.position有什么属性值，以及各自的区别
1. static(静态定位)，默认值，没有定位，元素出现在正常流中(忽略top、bottom、left、right或者z-index声明)
2. relative(相对定位)，生成相对定位的元素，通过top、bottom、left、right的设置相对于其正常(原先本身)进行定位，可通过z-index进行层次分级。
3. absolute(绝对定位)，生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位，没有得话就相对body，元素的位置通过left、top、right、bottom属性进行规定，可通过z-index进行层次分级
4. fixed(固定定位)，生成绝对定位的元素，相对于浏览器窗口进行定位，元素的位置通过left、top、right、bottom属性进行规定，可通过z-index进行层次分级


25.webpack如何打包多页面

26.模块化规范有什么

27.vue支持的模块化规范有哪些

28.vue3有什么新特性
1. 虚拟dom重写。将更有效的代码来创建虚拟节点
2. 优化slot的生成。目前Vue中，当父组件重新渲染时，其子组件也必须重新渲染。使用Vue3可以单独重新渲染父级和子级
3. 静态树提升。这意味着Vue3的编译器将能够检测到什么是静态的，然后将其提升，从而降低了渲染成本，它将能够跳过patching整棵树
4. 基于Proxy的Observation。目前，Vue的响应式系统是使用带有Object.defineProperty的getter和setter。但是，Vue3将使用ES2015 Proxy作为其观察机制，这消除了以前存在的警告，使速度加倍，并使用了一半的内存。Vue已经非常小了，在运行时压缩了大约20kb。但我们可以预期它会变得更加紧凑，对于新的核心运行时而言，为10kb gzi压缩。这将在很大程度上通过消除您不使用库(也称为Tree Shaking)来实现。例如，如果您没有使用过过渡元素，则不会包含它


29.作用域插槽
> 父组件需要用到子组件的数据
> https://www.jianshu.com/p/3f6ec6b09e9f

30.解决跨域的常用方式有哪些
>- CORS-跨域资源共享:Access-Control-Allow-Origin:
>- nginx的反向代理

31.前端发送json数据格式，需要配置什么
>- Content-Type: application/json;charset=UTF-8

32.JS高阶函数有什么
>- 传进来的变量是函数的函数或者函数作为返回值输出的函数
>- 有map、forEach、filter、reduce、reduceRight、sort、

33.严格模式
```javascript
  "use strict"
  x= 3.14;//报错(变量未定义)

  "use strict"
  x={p1:10,p2:20};//报错(变量未定义)

  "use strict"
  var x=3.14;
  delete x; //报错

  "use strict"
  function x(p1,p2){};
  delete x;//报错(不允许删除函数)

  "use strict"
  function x(p1,p1){};//报错(不允许变量重名)

  "use strict"
  var x = 010;//报错(不允许使用八进制)

  "use strict"
  var x = \010;//报错(不允许使用转义字符)

  "use strict"
  var obj = {};
  Object.defineProperty(obj,"x",{value:0,writable:false})
  obj.x=3.14;//报错(不允许对只读属性赋值)
  //非严格模式也不能改变，但是不会报错

  "use strict"
  var obj = {get x(){return 0}};
  obj.x = 3.14;//报错(不允许对一个使用getter方法读取的属性进行赋值)

  "use strict"
  delete Object.prototype;//报错(不允许删除不允许删除的属性)

  "use strict"
  var eval = 3.14;//报错(变量名不能使用"eval"字符串)

  "use strict"
  var arguments = 3.14;//报错(变量名不能使用arguments)

  "use strict"
  with(Math){x=cos(2)};//报错(不允许使用)

  "use strict"
  eval("var x = 2");
  alert(x);//报错(由于安全原因，在作用域eval()创建的变量不能被调用)

  //禁止this关键字指向全局对象
  function f(){
      return !this;
  } 
  // 返回false，因为"this"指向全局对象，"!this"就是false

  function f(){ 
      "use strict";
      return !this;
  } 
  // 返回true，因为严格模式下，this的值为undefined，所以"!this"为true。
```

34.虚拟dom(Virtual Dom)
>- vue.js 2.x 与vue.js 1.x 最大的区别就在于2.x使用了Virtual Dom（虚DOM）来更新DOM节点，提升渲染性能。一般我们的模板都是template当中的，但是vue编译时，都会解析为Virtual Dom。
>- Virtual Dom并不是真正意义上的DOM，而是一个轻量级的JavaScript对象，当状态发生变化时，Virtual Dom会进行Diff运算，来更新只需要被替换的DOM，而不是全部重绘，这样性能会好很多
>- 使用Virtual Dom就可以完全发挥JavaScript的编程能力，在多数场景中，我们使用template就足够了，但是一些特定的场景下，使用Virtrual Dom会更简单


## 友信
### 笔试
1.两个数组的交集、并集、时间复杂度
>- 参考：https://excaliburhan.com/post/js-set-operation.html

2.正则表达式

3.前端性能优化

4.前端安全

5.闭包

6.其他忘了

### 一面
1.vue如何定义指令
>- 参考：https://juejin.im/post/5a3933756fb9a045167d52b1

2.vue如何给自定义组件定义v-model
>- 参考：https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model

3.浏览器缓存

4.防抖节流

5.promise

6.async await

7.正则表达式的一些问题，没听过

8.js有哪些api

9.看比赛项目

10.实习做了什么

11.服务端渲染
1. 什么是服务端渲染
>- 将组件或页面通过服务端生成html字符串再发送到浏览器，最后将静态标记“混合”为客服端上完全交互的应用程序
>- 没使用服务端渲染，当请求index页面时，返回的body里为空，之后执行js将html结构注入到body里，结合css显示出来
>- 使用了服务端渲染，当请求index页面时，返回的body里已经有了首屏的html结构，之后结合css显示出来

2. 使用服务端SSR的利弊
>- 1. 更利于SEO
>- >- 不同爬虫工作原理类使，不会爬取源码，不会执行网站的任何脚本(Google除外，据说Googlebot可以运行JavaScript)。使用了React或者其他MVVM框架之后，页面大多数DOM元素都是在客户端根据JS动态生成，可供爬虫爬取分析的内容大大较少。另外，浏览器爬虫不会等待我们的数据完成之后再去爬取我们的页面数据。服务端渲染返回给客户端的是已经获取了异步数据并执行JavaScript脚本的最终html，网络爬虫就可以爬取到完整的页面
>- 2. 更利于首屏渲染
>- >- 首屏的渲染是node发送过来的html字符串，并不依赖于JavaScript文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后的文件体积比较大，普通客服端渲染加载所需文件事件较长，首页就会有一个很长的白屏等待时间

3. 服务端SSR的局限
>- 1. 服务端压力较大
>- >- 本来是通过客服端完成渲染，现在统一到服务端node服务去做。尤其是高并发访问的情况，会大量占用服务端CPU资源
>- 2. 开发条件受限
>- >- 在服务端渲染中，只会执行到componentDidMount之前的生命周期钩子，因此项目引用的第三方的库也不用其他生命周期钩子，这对引用库的选择产生了很大的限制
>- 3. 学习成本相对较高
>- >- 除了对webpack、React要熟悉，还要掌握node、Koa2等相关技术，相对于客服端渲染，项目构建，部署过程更加复杂

4. 时间消耗比较
>- 1. 数据请求
>- >- 由服务端请求首屏数据，而不是客服端请求首屏数据，这是“快”的一个主要原因。服务端在内网进行请求，数据相应速度快。客户端在不同网络环境进行数据请求，且外网http请求开销大，导致时间差。
>- 2. html渲染
>- >- 服务端渲染是先向后端服务端请求数据，然后生成完整首屏html返回浏览器，客户端渲染是等JavaScript代码下载、加载、解析完成后请求数据渲染，等待的过程页面是什么都没有的，就是用户看到的白屏。就是服务端渲染不需要等待JavaScript代码下载完成并请求数据，就可以返回一个已有完成数据的首屏页面

5. 总结
>- 服务端渲染不利于SEO搜索引擎优化，服务端渲染是可以被爬虫爬取到的，客户端异步渲染是很难被爬虫爬取到的，所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的，而是两者结合来做的。例如京东的商品列表就采用服务端渲染，目的为了SEO搜索引擎优化，而它的商品评论列表为了用户体验，而且也不需要SEO优化，所以采用客户端渲染
>- 不谈业务场景而盲目而盲目选择使用何种渲染方式都是耍流氓，比如企业级网站，主要功能是展示而没有复杂的交互，且需要良好的SEO，则这时我们就需要使用服务端渲染；而类似后台管理页面，交互性比较强，不需要seo的考虑，那么就可以使用客服端渲染


12.为什么要使用nuxt

13.webpack打包层度

### 二面
1.网络的七层协议

2.TUP、UDP、HTTP在哪一层

3.如何定义HTTP协议

4.HTTP1.0、HTTP2.0和HTTPS有什么区别

5.Vue、React、Angular有什么区别

6.学校事情

7.什么时候可以来实习


## 金蝶
### 一面
1.JS的发布者-订阅者模式
> 参考：https://segmentfault.com/a/1190000015405468

2.JS的类型

3.JS的继承

4.类型判断
> 1. typeof  
> typeof 返回一个表达式的数据类型的字符串，返回结果为javascript中的基本数据类型，包括：number、boolean、string、object、undefined、function等6种数据类型
> 2. instanceof   
> instanceof是通过原型判断的，比如 A instaceof B，A.__proto__ == B.prorotype，这里有个问题就是可以判断 [] 是数组Array，但是不能辨别 []不是Object。判断数组也可以通过es6的isArray方法
> 3. toString
```javascript
  console.log(Object.prototype.toString.call(123)) //[object Number]
  console.log(Object.prototype.toString.call('123')) //[object String]
  console.log(Object.prototype.toString.call(undefined)) //[object Undefined]
  console.log(Object.prototype.toString.call(true)) //[object Boolean]
  console.log(Object.prototype.toString.call({})) //[object Object]
  console.log(Object.prototype.toString.call([])) //[object Array]
  console.log(Object.prototype.toString.call(function(){})) //[object Function]
```

5.instanceof的弊端
> 这里有个问题就是可以判断 [] 是数组Array，但是不能辨别 []不是Object。判断数组也可以通过es6的isArray方法

6.浏览器缓存

7.sessionStorage、localStorage、cookie有什么区别

8.var、let、const有什么区别

9.防抖节流

10.如何实现一个hover、并且有时候会捕获不了，是为什么？
> 浏览器的内存保护吧，就是响应跟不上触发

11.vue的双向绑定

12.vue学到什么程度

13.移动端适配怎么理解，可以用媒体查询、flexible这些，要怎么选

14.服务端渲染的优点

15.promise

16.普通函数和箭头函数的区别

17.bind、apply、call有什么区别

18.组合继承的缺点
>- 创建的实例和原型上存在两份相同的属性

19.小程序开发和vue开发有什么区别

20.小程序有双向绑定？

21.公众号购课流程

22.公众号如何判断非法用户（疑惑）
> 对openId进行加密，可以采用加盐md5加密，或者采用crypto-js加密

23.js的事件循环机制，为什么要有宏任务和微任务
> 1. 因为宏任务是浏览器为了能够使得JS内部任务与DOM任务能够有序执行，会在一个任务执行结束之后，在下一个任务执行前对页面进行重新渲染
> 2. 微任务通常来说就是需要当 同步任务执行结束后立即执行的任务，比如对一系列动作做出反馈，或者是需要异步的执行任务而又不需要分配一个新的任务，这样便可以减小一点性能的开销

24.数据可视化，如果有大量数据要怎么处理

25.回调函数怎么理解，是异步的吗
> 1. 回调函数不都是异步的
> 2. 回调函数就是一个参数，将B函数作为参数传到A函数里面，当A函数执行完之后，再执行传进去的B函数。这个过程叫回调，而A函数就叫回调函数
```javascript
function A(callback){
  callback();
  console.log('我是主函数');
}

function B(){
  setTimeout(()=>{console.log('我是回调函数')},3000);//模拟耗时操作
}
A(B);
//输出结果
//我是主函数
//我是回调函数

```


26.跨域的解决方案

27.http和https的区别

28.https的缺点，中间人劫持
> 被劫持后也是费用的问题，破解需要钱  
> 使用中间人攻击手段，必须要让客户端信任中间人的证书，如果客户端不信任，则这种攻击手段也无法发挥作用。  
> 参考：https://blog.csdn.net/Linuxprobe18/article/details/79619339
。

29.JS的事件流

30.闭包

31.垃圾回收机制
> 1. 标记清除  
> 当变量进入环境（例如：在函数中定义一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们，而当变量离开时，则将其标记为“离开环境”。  
> 标记清除在运行的时候会给存储在内存中的所有变量都加上标记。然后，他会去掉环境中的变量以及被环境中的变量引用的变量的标记（环境中的变量以及被环境中的变量引用的变量是没有标记的）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收他们所占用的内存空间。

> 2. 引用计数
> 引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1.如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1.当这个值的引用次数为0时，则说明没有方法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，他就会释放那些引用次数为0的值所在的内存

31.面试官对我的评价
> 整体不错，知识面挺广的，需要多想些为什么，存在即合理

未来的规划
怎么学习
你的优势是什么







